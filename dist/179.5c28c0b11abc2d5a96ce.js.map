{"version":3,"file":"179.5c28c0b11abc2d5a96ce.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/assets/materials/sulphuric-rock_albedo.png","webpack://babylonjs-fluid-rendering/./src/assets/materials/sulphuric-rock_roughness.png","webpack://babylonjs-fluid-rendering/./src/assets/materials/sulphuric-rock_normal-ogl.png","webpack://babylonjs-fluid-rendering/./src/assets/materials/Marble08_1K_BaseColor.png","webpack://babylonjs-fluid-rendering/./src/scenes/Utils/sdfHelper.ts"],"sourcesContent":["export default __webpack_public_path__ + \"1927c2ee10e174350b0f2680480bac03.png\";","export default __webpack_public_path__ + \"42501ae63687985d3bdf75e684bf30b8.png\";","export default __webpack_public_path__ + \"de78498b6fd56d907b099104d11e9a2a.png\";","export default __webpack_public_path__ + \"cb9384751f5882e7f6eb9f8d4f333114.png\";","import * as BABYLON from \"@babylonjs/core\";\r\n\r\n// Textures from https://freepbr.com/materials/sulphuric-rock/\r\nimport rockBaseColor from \"../../assets/materials/sulphuric-rock_albedo.png\";\r\nimport rockRoughness from \"../../assets/materials/sulphuric-rock_roughness.png\";\r\nimport rockNormal from \"../../assets/materials/sulphuric-rock_normal-ogl.png\";\r\n\r\nimport marbleBaseColor from \"../../assets/materials/Marble08_1K_BaseColor.png\";\r\n\r\nconst eps = 0.0001;\r\n\r\nconst eps1 = new BABYLON.Vector3(eps, -eps, -eps);\r\nconst eps2 = new BABYLON.Vector3(-eps, -eps, eps);\r\nconst eps3 = new BABYLON.Vector3(-eps, eps, -eps);\r\nconst eps4 = new BABYLON.Vector3(eps, eps, eps);\r\n\r\nconst dir1 = new BABYLON.Vector3(1, -1, -1);\r\nconst dir2 = new BABYLON.Vector3(-1, -1, 1);\r\nconst dir3 = new BABYLON.Vector3(-1, 1, -1);\r\nconst dir4 = new BABYLON.Vector3(1, 1, 1);\r\n\r\nexport interface SDFArray {\r\n    origin: BABYLON.Vector3;\r\n    dimX: number;\r\n    dimY: number;\r\n    dimZ: number;\r\n    step: number;\r\n    data: number[];\r\n}\r\n\r\nexport interface ICollisionShape {\r\n    params: Array<any>;\r\n    sdEvaluate: (p: BABYLON.Vector3, ...args: any[]) => number;\r\n    computeNormal: (\r\n        pos: BABYLON.Vector3,\r\n        shape: ICollisionShape,\r\n        normal: BABYLON.Vector3\r\n    ) => void;\r\n    createMesh?: (\r\n        scene: BABYLON.Scene,\r\n        shape: ICollisionShape,\r\n        ...args: any[]\r\n    ) => Promise<BABYLON.Mesh>;\r\n    transf: BABYLON.Matrix;\r\n    invTransf: BABYLON.Matrix;\r\n    scale: number;\r\n    position?: BABYLON.Vector3;\r\n    rotation?: BABYLON.Vector3;\r\n    rotationQuaternion?: BABYLON.Quaternion;\r\n    mesh?: BABYLON.Mesh;\r\n    dragPlane: BABYLON.Nullable<BABYLON.Vector3>;\r\n    disabled?: boolean;\r\n    collisionRestitution?: number;\r\n}\r\n\r\nexport class SDFHelper {\r\n    public static CreateBox(\r\n        scene: BABYLON.Scene,\r\n        shape: ICollisionShape,\r\n        extents: BABYLON.Vector3\r\n    ) {\r\n        const box = BABYLON.MeshBuilder.CreateBox(\r\n            \"box\",\r\n            {\r\n                width: extents.x * 2,\r\n                height: extents.y * 2,\r\n                depth: extents.z * 2,\r\n            },\r\n            scene\r\n        );\r\n\r\n        const material = new BABYLON.PBRMaterial(\"boxMat\", scene);\r\n\r\n        material.metallic = 0;\r\n        material.roughness = 0.9;\r\n        material.albedoTexture = new BABYLON.Texture(\r\n            \"https://playground.babylonjs.com/textures/wood.jpg\",\r\n            scene\r\n        );\r\n        material.cullBackFaces = true;\r\n\r\n        box.material = material;\r\n\r\n        return Promise.resolve(box);\r\n    }\r\n\r\n    public static CreateSphere(\r\n        scene: BABYLON.Scene,\r\n        shape: ICollisionShape,\r\n        s: number\r\n    ) {\r\n        const sphere = BABYLON.MeshBuilder.CreateSphere(\r\n            \"sphere\",\r\n            { diameter: s * 2, segments: 16 },\r\n            scene\r\n        );\r\n\r\n        const material = new BABYLON.PBRMaterial(\"sphereMat\", scene);\r\n\r\n        material.metallic = 1;\r\n        material.roughness = 0.05;\r\n        material.albedoTexture = new BABYLON.Texture(marbleBaseColor, scene);\r\n        material.cullBackFaces = true;\r\n\r\n        sphere.material = material;\r\n\r\n        return Promise.resolve(sphere);\r\n    }\r\n\r\n    public static CreateCutHollowSphere(\r\n        scene: BABYLON.Scene,\r\n        shape: ICollisionShape,\r\n        radius: number,\r\n        planeDist: number,\r\n        thickness: number,\r\n        segments: number\r\n    ) {\r\n        thickness = thickness / radius;\r\n\r\n        const sphere = BABYLON.MeshBuilder.CreateSphere(\r\n            \"sphere\",\r\n            { diameter: radius * 2, segments },\r\n            scene\r\n        );\r\n        const plane = BABYLON.MeshBuilder.CreatePlane(\r\n            \"plane\",\r\n            { size: radius * 2 },\r\n            scene\r\n        );\r\n\r\n        plane.rotation.y = Math.PI / 2;\r\n        plane.position.x = planeDist;\r\n\r\n        const csg1 = BABYLON.CSG.FromMesh(sphere);\r\n        const csgp = BABYLON.CSG.FromMesh(plane);\r\n\r\n        sphere.dispose();\r\n        plane.dispose();\r\n\r\n        csg1.subtractInPlace(csgp);\r\n\r\n        const mesh = csg1.toMesh(\"sppl\");\r\n\r\n        mesh.computeWorldMatrix(true);\r\n        mesh.refreshBoundingInfo();\r\n\r\n        mesh.scaling.setAll(1 - thickness);\r\n        mesh.position.x =\r\n            mesh.getBoundingInfo().boundingBox.maximumWorld.x * thickness;\r\n\r\n        const csg2 = BABYLON.CSG.FromMesh(mesh);\r\n\r\n        mesh.dispose();\r\n\r\n        csg1.subtractInPlace(csg2);\r\n\r\n        const meshFinal = csg1.toMesh(\"cutHollowSphere\");\r\n\r\n        meshFinal.rotation.z = Math.PI / 2;\r\n        meshFinal.bakeCurrentTransformIntoVertices();\r\n\r\n        const material = new BABYLON.PBRMaterial(\"cutHollowSphereMat\", scene);\r\n\r\n        material.metallic = 1;\r\n        material.roughness = 0.05;\r\n        material.albedoTexture = new BABYLON.Texture(marbleBaseColor, scene);\r\n        material.cullBackFaces = true;\r\n\r\n        meshFinal.material = material;\r\n\r\n        return Promise.resolve(meshFinal);\r\n    }\r\n\r\n    public static CreateVerticalCylinder(\r\n        scene: BABYLON.Scene,\r\n        shape: ICollisionShape,\r\n        r: number,\r\n        h: number,\r\n        segments: number\r\n    ) {\r\n        const cylinder = BABYLON.MeshBuilder.CreateCylinder(\r\n            \"cylinder\",\r\n            { diameter: r * 2, height: h, tessellation: segments },\r\n            scene\r\n        );\r\n\r\n        const material = new BABYLON.PBRMaterial(\"cylinderMat\", scene);\r\n\r\n        material.metallic = 1;\r\n        material.roughness = 0.05;\r\n        material.albedoTexture = new BABYLON.Texture(marbleBaseColor, scene);\r\n        material.cullBackFaces = true;\r\n\r\n        cylinder.material = material;\r\n\r\n        return Promise.resolve(cylinder);\r\n    }\r\n\r\n    public static CreateTerrain(\r\n        scene: BABYLON.Scene,\r\n        shape: ICollisionShape,\r\n        size: number\r\n    ) {\r\n        const ground = BABYLON.MeshBuilder.CreateGroundFromHeightMap(\r\n            \"terrain\",\r\n            \"https://playground.babylonjs.com/textures/heightMap.png\",\r\n            {\r\n                width: size,\r\n                height: size,\r\n                subdivisions: 128,\r\n                maxHeight: size / 5,\r\n                onReady: () => ground!.updateCoordinateHeights(),\r\n            },\r\n            scene\r\n        );\r\n\r\n        const mat = new BABYLON.PBRMaterial(\"mat\", scene);\r\n\r\n        mat.metallicTexture = new BABYLON.Texture(rockRoughness, scene);\r\n        mat.albedoTexture = new BABYLON.Texture(rockBaseColor, scene);\r\n        mat.bumpTexture = new BABYLON.Texture(rockNormal, scene);\r\n        mat.useRoughnessFromMetallicTextureGreen = true;\r\n        mat.metallic = 0;\r\n        mat.roughness = 1;\r\n\r\n        ground.material = mat;\r\n\r\n        shape.params.push(ground);\r\n\r\n        return Promise.resolve(ground);\r\n    }\r\n\r\n    protected static _ParseSDFData(textData: string): SDFArray {\r\n        const lines = textData.replace(\"\\r\", \"\").split(\"\\n\");\r\n\r\n        const dimLine = lines[0].split(\" \");\r\n\r\n        const dimX = parseFloat(dimLine[0]);\r\n        const dimY = parseFloat(dimLine[1]);\r\n        const dimZ = parseFloat(dimLine[2]);\r\n\r\n        const originLine = lines[1].split(\" \");\r\n\r\n        const origin = new BABYLON.Vector3(\r\n            parseFloat(originLine[0]),\r\n            parseFloat(originLine[1]),\r\n            parseFloat(originLine[2])\r\n        );\r\n\r\n        const step = parseFloat(lines[2]);\r\n\r\n        const data: number[] = [];\r\n\r\n        for (let i = 3; i < lines.length; ++i) {\r\n            const val = lines[i];\r\n            if (val.length === 0) {\r\n                continue;\r\n            }\r\n            data.push(parseFloat(val));\r\n        }\r\n\r\n        return {\r\n            dimX,\r\n            dimY,\r\n            dimZ,\r\n            origin,\r\n            step,\r\n            data,\r\n        };\r\n    }\r\n\r\n    public static CreateMesh(\r\n        scene: BABYLON.Scene,\r\n        shape: ICollisionShape,\r\n        meshFilename: string,\r\n        sdfFilename: string,\r\n        createNormals: boolean\r\n    ): Promise<BABYLON.Mesh> {\r\n        return new Promise((resolve) => {\r\n            const promises = [\r\n                BABYLON.SceneLoader.ImportMeshAsync(\r\n                    \"\",\r\n                    \"src/assets/scenes/\",\r\n                    meshFilename,\r\n                    scene\r\n                ),\r\n                new Promise((resolve) => {\r\n                    fetch(\"../src/assets/sdf/\" + sdfFilename).then((response) => {\r\n                        response.text().then((text) => {\r\n                            shape.params.push(SDFHelper._ParseSDFData(text));\r\n                            resolve(void 0);\r\n                        });\r\n                    });\r\n                }),\r\n            ];\r\n\r\n            Promise.all(promises).then((results) => {\r\n                const meshes = results[0] as BABYLON.ISceneLoaderAsyncResult;\r\n                const mesh = meshes.meshes[0] as BABYLON.Mesh;\r\n                if (!mesh.material) {\r\n                    const material = new BABYLON.PBRMaterial(\"meshMat\", scene);\r\n\r\n                    material.metallic = 1;\r\n                    material.roughness = 0.05;\r\n                    material.albedoTexture = new BABYLON.Texture(\r\n                        rockBaseColor,\r\n                        scene\r\n                    );\r\n                    material.cullBackFaces = true;\r\n\r\n                    mesh.material = material;\r\n                }\r\n                if (createNormals) {\r\n                    mesh.createNormals(false);\r\n                }\r\n                mesh.scaling.setAll(shape.scale);\r\n                resolve(mesh);\r\n            });\r\n        });\r\n    }\r\n\r\n    // SD functions from https://iquilezles.org/articles/distfunctions/\r\n    public static SDBox(p: BABYLON.Vector3, b: BABYLON.Vector3) {\r\n        const q = BABYLON.TmpVectors.Vector3[0];\r\n        q.copyFromFloats(Math.abs(p.x), Math.abs(p.y), Math.abs(p.z));\r\n        q.subtractInPlace(b);\r\n\r\n        const tmp = Math.min(Math.max(q.x, q.y, q.z), 0);\r\n\r\n        q.maximizeInPlaceFromFloats(0, 0, 0);\r\n\r\n        return q.length() + tmp;\r\n    }\r\n\r\n    public static SDSphere(p: BABYLON.Vector3, s: number) {\r\n        return p.length() - s;\r\n    }\r\n\r\n    public static SDPlane(p: BABYLON.Vector3, n: BABYLON.Vector3, h: number) {\r\n        return BABYLON.Vector3.Dot(p, n) + h;\r\n    }\r\n\r\n    public static SDCutHollowSphere(\r\n        p: BABYLON.Vector3,\r\n        r: number,\r\n        h: number,\r\n        t: number\r\n    ) {\r\n        // sampling independent computations (only depend on shape)\r\n        const w = Math.sqrt(r * r - h * h);\r\n\r\n        // sampling dependant computations\r\n        const qx = Math.sqrt(p.x * p.x + p.z * p.z);\r\n        const qy = p.y;\r\n\r\n        if (h * qx < w * qy) {\r\n            return Math.sqrt((qx - w) * (qx - w) + (qy - h) * (qy - h));\r\n        }\r\n\r\n        return Math.abs(Math.sqrt(qx * qx + qy * qy) - r) - t;\r\n    }\r\n\r\n    public static SDVerticalCylinder(p: BABYLON.Vector3, r: number, h: number) {\r\n        const dx = Math.abs(Math.sqrt(p.x * p.x + p.z * p.z)) - r;\r\n        const dy = Math.abs(p.y) - h;\r\n        const dx2 = Math.max(dx, 0);\r\n        const dy2 = Math.max(dy, 0);\r\n\r\n        return (\r\n            Math.min(Math.max(dx, dy), 0.0) + Math.sqrt(dx2 * dx2 + dy2 * dy2)\r\n        );\r\n    }\r\n\r\n    public static SDTerrain(\r\n        p: BABYLON.Vector3,\r\n        size: number,\r\n        terrain: BABYLON.GroundMesh\r\n    ) {\r\n        return p.y - terrain.getHeightAtCoordinates(p.x, p.z);\r\n    }\r\n\r\n    public static SDMesh(\r\n        p: BABYLON.Vector3,\r\n        meshFilename: string,\r\n        sdfFilename: string,\r\n        createNormals: boolean,\r\n        sdf: SDFArray\r\n    ) {\r\n        const x = (p.x - sdf.origin.x) / sdf.step;\r\n        const y = (p.y - sdf.origin.y) / sdf.step;\r\n        const z = (p.z - sdf.origin.z) / sdf.step;\r\n\r\n        let gx = Math.floor(x);\r\n        let gy = Math.floor(y);\r\n        let gz = Math.floor(z);\r\n\r\n        gx = Math.max(Math.min(gx, sdf.dimX - 2), 0);\r\n        gy = Math.max(Math.min(gy, sdf.dimY - 2), 0);\r\n        gz = Math.max(Math.min(gz, sdf.dimZ - 2), 0);\r\n\r\n        // trilinear filtering\r\n        const fx = x - gx;\r\n        const fy = y - gy;\r\n        const fz = z - gz;\r\n\r\n        const a00 = sdf.data[gz * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx];\r\n        const a10 = sdf.data[gz * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx + 1];\r\n        const a11 =\r\n            sdf.data[gz * sdf.dimY * sdf.dimX + (gy + 1) * sdf.dimX + gx + 1];\r\n        const a01 =\r\n            sdf.data[gz * sdf.dimY * sdf.dimX + (gy + 1) * sdf.dimX + gx];\r\n\r\n        const a0 = a00 * (1 - fx) + a10 * fx;\r\n        const a1 = a01 * (1 - fx) + a11 * fx;\r\n        const a = a0 * (1 - fy) + a1 * fy;\r\n\r\n        const b00 =\r\n            sdf.data[(gz + 1) * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx];\r\n        const b10 =\r\n            sdf.data[(gz + 1) * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx + 1];\r\n        const b11 =\r\n            sdf.data[\r\n                (gz + 1) * sdf.dimY * sdf.dimX + (gy + 1) * sdf.dimX + gx + 1\r\n            ];\r\n        const b01 =\r\n            sdf.data[(gz + 1) * sdf.dimY * sdf.dimX + (gy + 1) * sdf.dimX + gx];\r\n\r\n        const b0 = b00 * (1 - fx) + b10 * fx;\r\n        const b1 = b01 * (1 - fx) + b11 * fx;\r\n        const b = b0 * (1 - fy) + b1 * fy;\r\n\r\n        const d = a * (1 - fz) + b * fz;\r\n        //const d = sdf.data[gz * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx];\r\n\r\n        return d;\r\n    }\r\n\r\n    // normal computed with the Tetrahedron technique, see https://iquilezles.org/articles/normalsSDF/\r\n    public static ComputeSDFNormal(\r\n        pos: BABYLON.Vector3,\r\n        shape: ICollisionShape,\r\n        normal: BABYLON.Vector3\r\n    ) {\r\n        const posTemp = BABYLON.TmpVectors.Vector3[5];\r\n        const dir = BABYLON.TmpVectors.Vector3[6];\r\n\r\n        normal.copyFromFloats(0, 0, 0);\r\n\r\n        posTemp.copyFrom(pos);\r\n        dir.copyFrom(dir1);\r\n        normal.addInPlace(\r\n            dir.scaleInPlace(\r\n                shape.sdEvaluate(posTemp.addInPlace(eps1), ...shape.params)\r\n            )\r\n        );\r\n\r\n        posTemp.copyFrom(pos);\r\n        dir.copyFrom(dir2);\r\n        normal.addInPlace(\r\n            dir.scaleInPlace(\r\n                shape.sdEvaluate(posTemp.addInPlace(eps2), ...shape.params)\r\n            )\r\n        );\r\n\r\n        posTemp.copyFrom(pos);\r\n        dir.copyFrom(dir3);\r\n        normal.addInPlace(\r\n            dir.scaleInPlace(\r\n                shape.sdEvaluate(posTemp.addInPlace(eps3), ...shape.params)\r\n            )\r\n        );\r\n\r\n        posTemp.copyFrom(pos);\r\n        dir.copyFrom(dir4);\r\n        normal.addInPlace(\r\n            dir.scaleInPlace(\r\n                shape.sdEvaluate(posTemp.addInPlace(eps4), ...shape.params)\r\n            )\r\n        );\r\n\r\n        BABYLON.Vector3.TransformNormalToRef(normal, shape.transf, normal);\r\n\r\n        normal.normalize();\r\n    }\r\n\r\n    public static ComputeTerrainNormal(\r\n        pos: BABYLON.Vector3,\r\n        shape: ICollisionShape,\r\n        normal: BABYLON.Vector3\r\n    ) {\r\n        const terrain = shape.params[1] as BABYLON.GroundMesh;\r\n\r\n        terrain.getNormalAtCoordinatesToRef(pos.x, pos.z, normal);\r\n    }\r\n}\r\n"],"names":["eps","eps1","eps2","eps3","eps4","dir1","dir2","dir3","dir4","SDFHelper","static","scene","shape","extents","box","width","x","height","y","depth","z","material","metallic","roughness","albedoTexture","cullBackFaces","Promise","resolve","s","sphere","diameter","segments","radius","planeDist","thickness","plane","size","rotation","Math","PI","position","csg1","csgp","dispose","subtractInPlace","mesh","toMesh","computeWorldMatrix","refreshBoundingInfo","scaling","setAll","getBoundingInfo","boundingBox","maximumWorld","csg2","meshFinal","bakeCurrentTransformIntoVertices","r","h","cylinder","tessellation","ground","subdivisions","maxHeight","onReady","updateCoordinateHeights","mat","metallicTexture","bumpTexture","useRoughnessFromMetallicTextureGreen","params","push","textData","lines","replace","split","dimLine","dimX","parseFloat","dimY","dimZ","originLine","origin","step","data","i","length","val","meshFilename","sdfFilename","createNormals","promises","fetch","then","response","text","_ParseSDFData","all","results","meshes","scale","p","b","q","copyFromFloats","abs","tmp","min","max","maximizeInPlaceFromFloats","n","t","w","sqrt","qx","qy","dx","dy","dx2","dy2","terrain","getHeightAtCoordinates","sdf","gx","floor","gy","gz","fx","fy","fz","a00","a10","a11","a","b00","b10","b11","pos","normal","posTemp","dir","copyFrom","addInPlace","scaleInPlace","sdEvaluate","transf","normalize","getNormalAtCoordinatesToRef"],"sourceRoot":""}