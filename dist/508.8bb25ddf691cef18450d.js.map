{"version":3,"file":"508.8bb25ddf691cef18450d.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderer.ts","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleDepth.vertex.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleDepth.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleThickness.vertex.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleThickness.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleDiffuse.vertex.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleDiffuse.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/bilateralBlur.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/standardBlur.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/renderFluid.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/renderFluid.fragment.wgsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/passDepth.vertex.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/passDepth.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/passDepth.vertex.wgsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/passDepth.fragment.wgsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/postprocess.vertex.wgsl","webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderingObject.ts","webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderingObjectParticleSystem.ts","webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderingObjectVertexBuffer.ts","webpack://babylonjs-fluid-rendering/./src/scenes/Utils/copyDepthTexture.ts"],"sourcesContent":["import * as BABYLON from \"@babylonjs/core\";\r\n\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\nimport { FluidRenderingObject } from \"./fluidRenderingObject\";\r\n\r\nimport particleDepthVertex from \"../../assets/shaders/particleDepth.vertex.glsl\";\r\nimport particleDepthFragment from \"../../assets/shaders/particleDepth.fragment.glsl\";\r\n\r\nimport particleThicknessVertex from \"../../assets/shaders/particleThickness.vertex.glsl\";\r\nimport particleThicknessFragment from \"../../assets/shaders/particleThickness.fragment.glsl\";\r\n\r\nimport particleDiffuseVertex from \"../../assets/shaders/particleDiffuse.vertex.glsl\";\r\nimport particleDiffuseFragment from \"../../assets/shaders/particleDiffuse.fragment.glsl\";\r\n\r\nimport bilateralBlurFragment from \"../../assets/shaders/bilateralBlur.fragment.glsl\";\r\nimport standardBlurFragment from \"../../assets/shaders/standardBlur.fragment.glsl\";\r\n\r\nimport renderFluidFragment from \"../../assets/shaders/renderFluid.fragment.glsl\";\r\nimport renderFluidWGSLFragment from \"../../assets/shaders/renderFluid.fragment.wgsl\";\r\n\r\nimport passDepthVertex from \"../../assets/shaders/passDepth.vertex.glsl\";\r\nimport passDepthFragment from \"../../assets/shaders/passDepth.fragment.glsl\";\r\n\r\nimport passDepthWGSLVertex from \"../../assets/shaders/passDepth.vertex.wgsl\";\r\nimport passDepthWGSLFragment from \"../../assets/shaders/passDepth.fragment.wgsl\";\r\n\r\nimport postprocessWGSLVertex from \"../../assets/shaders/postprocess.vertex.wgsl\";\r\n\r\nimport { FluidRenderingObjectParticleSystem } from \"./fluidRenderingObjectParticleSystem\";\r\nimport { FluidRenderingTargetRenderer } from \"./fluidRenderingTargetRenderer\";\r\nimport { FluidRenderingObjectVertexBuffer } from \"./fluidRenderingObjectVertexBuffer\";\r\nimport { CopyDepthTexture } from \"scenes/Utils/copyDepthTexture\";\r\n\r\ndeclare module \"@babylonjs/core/Particles/IParticleSystem\" {\r\n    export interface IParticleSystem {\r\n        renderAsFluid: boolean;\r\n    }\r\n}\r\n\r\ndeclare module \"@babylonjs/core/Particles/ParticleSystem\" {\r\n    export interface ParticleSystem {\r\n        /** @hidden (Backing field) */\r\n        _renderAsFluid: boolean;\r\n\r\n        renderAsFluid: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(BABYLON.ParticleSystem.prototype, \"renderAsFluid\", {\r\n    get: function (this: BABYLON.ParticleSystem) {\r\n        return this._renderAsFluid;\r\n    },\r\n    set: function (this: BABYLON.ParticleSystem, value: boolean) {\r\n        this._renderAsFluid = value;\r\n        this._scene?.fluidRenderer?.collectParticleSystems();\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nexport interface IFluidRenderingRenderObject {\r\n    object: FluidRenderingObject;\r\n    targetRenderer: FluidRenderingTargetRenderer;\r\n}\r\n\r\nexport class FluidRenderer {\r\n    /** @hidden */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void =\r\n        (/*_*/) => {\r\n            throw `FluidRendererSceneComponent needs to be imported before as it contains a side-effect required by your code.`;\r\n        };\r\n\r\n    private _scene: BABYLON.Scene;\r\n    private _engine: BABYLON.Engine;\r\n    private _onEngineResizeObserver: BABYLON.Nullable<\r\n        BABYLON.Observer<BABYLON.Engine>\r\n    >;\r\n    private _renderObjects: Array<IFluidRenderingRenderObject>;\r\n    private _targetRenderers: FluidRenderingTargetRenderer[];\r\n    private _cameras: Map<\r\n        BABYLON.Camera,\r\n        [\r\n            Array<FluidRenderingTargetRenderer>,\r\n            { [key: string]: CopyDepthTexture }\r\n        ]\r\n    >;\r\n\r\n    public get renderObjects() {\r\n        return this._renderObjects;\r\n    }\r\n\r\n    public get targetRenderers() {\r\n        return this._targetRenderers;\r\n    }\r\n\r\n    constructor(scene: BABYLON.Scene) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._onEngineResizeObserver = null;\r\n        this._renderObjects = [];\r\n        this._targetRenderers = [];\r\n        this._cameras = new Map();\r\n\r\n        FluidRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        this._onEngineResizeObserver = this._engine.onResizeObservable.add(\r\n            () => {\r\n                this._initialize();\r\n            }\r\n        );\r\n\r\n        this.collectParticleSystems();\r\n    }\r\n\r\n    public recreate(): void {\r\n        this._sortRenderingObjects();\r\n        this._initialize();\r\n    }\r\n\r\n    public getRenderObjectFromParticleSystem(\r\n        ps: BABYLON.ParticleSystem\r\n    ): BABYLON.Nullable<IFluidRenderingRenderObject> {\r\n        const index = this._getParticleSystemIndex(ps);\r\n        return index !== -1 ? this._renderObjects[index] : null;\r\n    }\r\n\r\n    public getRenderObjectFromVertexBuffer(\r\n        vb: BABYLON.VertexBuffer\r\n    ): BABYLON.Nullable<IFluidRenderingRenderObject> {\r\n        const index = this._getVertexBufferIndex(vb);\r\n        return index !== -1 ? this._renderObjects[index] : null;\r\n    }\r\n\r\n    public addParticleSystem(\r\n        ps: BABYLON.ParticleSystem,\r\n        generateDiffuseTexture?: boolean,\r\n        targetRenderer?: FluidRenderingTargetRenderer,\r\n        camera?: BABYLON.Camera\r\n    ): IFluidRenderingRenderObject {\r\n        const object = new FluidRenderingObjectParticleSystem(this._scene, ps);\r\n\r\n        object.onParticleSizeChanged.add(\r\n            this._setParticleSizeForRenderTargets.bind(this)\r\n        );\r\n\r\n        if (!targetRenderer) {\r\n            targetRenderer = new FluidRenderingTargetRenderer(\r\n                this._scene,\r\n                camera\r\n            );\r\n            this._targetRenderers.push(targetRenderer);\r\n        }\r\n\r\n        if (!targetRenderer.onUseVelocityChanged.hasObservers()) {\r\n            targetRenderer.onUseVelocityChanged.add(\r\n                this._setUseVelocityForRenderObject.bind(this)\r\n            );\r\n        }\r\n\r\n        if (generateDiffuseTexture !== undefined) {\r\n            targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\r\n        }\r\n\r\n        const renderObject = { object, targetRenderer };\r\n\r\n        this._renderObjects.push(renderObject);\r\n\r\n        this._sortRenderingObjects();\r\n\r\n        this._setParticleSizeForRenderTargets();\r\n\r\n        return renderObject;\r\n    }\r\n\r\n    public addVertexBuffer(\r\n        vertexBuffers: { [key: string]: BABYLON.VertexBuffer },\r\n        numParticles: number,\r\n        generateDiffuseTexture?: boolean,\r\n        targetRenderer?: FluidRenderingTargetRenderer,\r\n        camera?: BABYLON.Camera\r\n    ): IFluidRenderingRenderObject {\r\n        const object = new FluidRenderingObjectVertexBuffer(\r\n            this._scene,\r\n            vertexBuffers,\r\n            numParticles\r\n        );\r\n\r\n        object.onParticleSizeChanged.add(\r\n            this._setParticleSizeForRenderTargets.bind(this)\r\n        );\r\n\r\n        if (!targetRenderer) {\r\n            targetRenderer = new FluidRenderingTargetRenderer(\r\n                this._scene,\r\n                camera\r\n            );\r\n            this._targetRenderers.push(targetRenderer);\r\n        }\r\n\r\n        if (!targetRenderer.onUseVelocityChanged.hasObservers()) {\r\n            targetRenderer.onUseVelocityChanged.add(\r\n                this._setUseVelocityForRenderObject.bind(this)\r\n            );\r\n        }\r\n\r\n        if (generateDiffuseTexture !== undefined) {\r\n            targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\r\n        }\r\n\r\n        const renderObject = { object, targetRenderer };\r\n\r\n        this._renderObjects.push(renderObject);\r\n\r\n        this._sortRenderingObjects();\r\n\r\n        this._setParticleSizeForRenderTargets();\r\n\r\n        return renderObject;\r\n    }\r\n\r\n    public removeRenderObject(\r\n        renderObject: IFluidRenderingRenderObject,\r\n        removeUnusedTargetRenderer = true\r\n    ): boolean {\r\n        const index = this._renderObjects.indexOf(renderObject);\r\n        if (index === -1) {\r\n            return false;\r\n        }\r\n\r\n        renderObject.object.dispose();\r\n\r\n        this._renderObjects.splice(index, 1);\r\n\r\n        if (removeUnusedTargetRenderer && this._removeUnusedTargetRenderers()) {\r\n            this._initialize();\r\n        } else {\r\n            this._setParticleSizeForRenderTargets();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _sortRenderingObjects(): void {\r\n        this._renderObjects.sort((a, b) => {\r\n            return a.object.priority < b.object.priority\r\n                ? -1\r\n                : a.object.priority > b.object.priority\r\n                ? 1\r\n                : 0;\r\n        });\r\n    }\r\n\r\n    public collectParticleSystems(): void {\r\n        for (let i = 0; i < this._scene.particleSystems.length; ++i) {\r\n            const ps = this._scene.particleSystems[i];\r\n            const index = this._getParticleSystemIndex(ps);\r\n            if (index === -1) {\r\n                if (\r\n                    ps.renderAsFluid &&\r\n                    ps.getClassName() === \"ParticleSystem\"\r\n                ) {\r\n                    this.addParticleSystem(ps as BABYLON.ParticleSystem, true);\r\n                }\r\n            } else if (!ps.renderAsFluid) {\r\n                this._renderObjects[index].object.dispose();\r\n                this._renderObjects.splice(index, 1);\r\n            }\r\n        }\r\n        this._removeUnusedTargetRenderers();\r\n        this._initialize();\r\n    }\r\n\r\n    private _removeUnusedTargetRenderers(): boolean {\r\n        const indexes: { [id: number]: boolean } = {};\r\n\r\n        for (let i = 0; i < this._renderObjects.length; ++i) {\r\n            const targetRenderer = this._renderObjects[i].targetRenderer;\r\n            indexes[this._targetRenderers.indexOf(targetRenderer)] = true;\r\n        }\r\n\r\n        let removed = false;\r\n        const newList: Array<FluidRenderingTargetRenderer> = [];\r\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\r\n            if (!indexes[i]) {\r\n                this._targetRenderers[i].dispose();\r\n                removed = true;\r\n            } else {\r\n                newList.push(this._targetRenderers[i]);\r\n            }\r\n        }\r\n\r\n        if (removed) {\r\n            this._targetRenderers.length = 0;\r\n            this._targetRenderers.push(...newList);\r\n        }\r\n\r\n        return removed;\r\n    }\r\n\r\n    private static _IsParticleSystemObject(\r\n        obj: FluidRenderingObject\r\n    ): obj is FluidRenderingObjectParticleSystem {\r\n        return !!(obj as FluidRenderingObjectParticleSystem).particleSystem;\r\n    }\r\n\r\n    private static _IsVertexBufferObject(\r\n        obj: FluidRenderingObject\r\n    ): obj is FluidRenderingObjectVertexBuffer {\r\n        return (\r\n            (obj as FluidRenderingObjectVertexBuffer).getClassName() ===\r\n            \"FluidRenderingObjectVertexBuffer\"\r\n        );\r\n    }\r\n\r\n    private _getParticleSystemIndex(ps: BABYLON.IParticleSystem): number {\r\n        for (let i = 0; i < this._renderObjects.length; ++i) {\r\n            const obj = this._renderObjects[i].object;\r\n            if (\r\n                FluidRenderer._IsParticleSystemObject(obj) &&\r\n                obj.particleSystem === ps\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    private _getVertexBufferIndex(vb: BABYLON.VertexBuffer): number {\r\n        for (let i = 0; i < this._renderObjects.length; ++i) {\r\n            const obj = this._renderObjects[i].object;\r\n            if (\r\n                FluidRenderer._IsVertexBufferObject(obj) &&\r\n                obj.vertexBuffers[BABYLON.VertexBuffer.PositionKind] === vb\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    private _initialize(): void {\r\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\r\n            this._targetRenderers[i].dispose();\r\n        }\r\n\r\n        const cameras: Map<\r\n            BABYLON.Camera,\r\n            [\r\n                Array<FluidRenderingTargetRenderer>,\r\n                { [key: string]: CopyDepthTexture }\r\n            ]\r\n        > = new Map();\r\n\r\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\r\n            const targetRenderer = this._targetRenderers[i];\r\n\r\n            targetRenderer.initialize();\r\n\r\n            if (targetRenderer.camera && targetRenderer.renderPostProcess) {\r\n                let list = cameras.get(targetRenderer.camera);\r\n                if (!list) {\r\n                    list = [[], {}];\r\n                    cameras.set(targetRenderer.camera, list);\r\n                }\r\n                list[0].push(targetRenderer);\r\n                targetRenderer.camera.attachPostProcess(\r\n                    targetRenderer.renderPostProcess,\r\n                    i\r\n                );\r\n            }\r\n        }\r\n\r\n        for (const [camera, list] of cameras) {\r\n            const firstPostProcess = camera._getFirstPostProcess();\r\n            if (!firstPostProcess) {\r\n                continue;\r\n            }\r\n\r\n            const [targetRenderers, copyDepthTextures] = list;\r\n\r\n            firstPostProcess.onSizeChangedObservable.add(() => {\r\n                if (!firstPostProcess.inputTexture.depthStencilTexture) {\r\n                    firstPostProcess.inputTexture.createDepthStencilTexture(\r\n                        0,\r\n                        true,\r\n                        this._engine.isStencilEnable,\r\n                        targetRenderers[0].samples\r\n                    );\r\n                }\r\n                for (const targetRenderer of targetRenderers) {\r\n                    const thicknessRT =\r\n                        targetRenderer.thicknessRenderTarget?.renderTarget;\r\n                    const thicknessTexture = thicknessRT?.texture;\r\n                    if (thicknessRT && thicknessTexture) {\r\n                        const key =\r\n                            thicknessTexture.width +\r\n                            \"_\" +\r\n                            thicknessTexture.height;\r\n                        let copyDepthTexture = copyDepthTextures[key];\r\n                        if (!copyDepthTexture) {\r\n                            copyDepthTexture = copyDepthTextures[key] =\r\n                                new CopyDepthTexture(\r\n                                    this._engine,\r\n                                    thicknessTexture.width,\r\n                                    thicknessTexture.height\r\n                                );\r\n                        }\r\n                        copyDepthTexture.depthRTWrapper._shareDepth(\r\n                            thicknessRT\r\n                        );\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // Dispose the CopyDepthTexture instances that we don't need anymore\r\n        for (const [camera, list] of this._cameras) {\r\n            const copyDepthTextures = list[1];\r\n\r\n            const list2 = cameras.get(camera);\r\n            if (!list2) {\r\n                for (const key in copyDepthTextures) {\r\n                    copyDepthTextures[key].dispose();\r\n                }\r\n            } else {\r\n                for (const key in copyDepthTextures) {\r\n                    if (!list2[1][key]) {\r\n                        copyDepthTextures[key].dispose();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._cameras.clear();\r\n        this._cameras = cameras;\r\n\r\n        this._setParticleSizeForRenderTargets();\r\n    }\r\n\r\n    private _setParticleSizeForRenderTargets(): void {\r\n        const particleSizes = new Map<FluidRenderingTargetRenderer, number>();\r\n\r\n        for (let i = 0; i < this._renderObjects.length; ++i) {\r\n            const renderingObject = this._renderObjects[i];\r\n            let curSize = particleSizes.get(renderingObject.targetRenderer);\r\n            if (curSize === undefined) {\r\n                curSize = 0;\r\n            }\r\n            particleSizes.set(\r\n                renderingObject.targetRenderer,\r\n                Math.max(curSize, renderingObject.object.particleSize)\r\n            );\r\n        }\r\n\r\n        for (const [targetRenderer, particleSize] of particleSizes) {\r\n            if (targetRenderer.depthRenderTarget) {\r\n                targetRenderer.depthRenderTarget.particleSize = particleSize;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setUseVelocityForRenderObject(): void {\r\n        for (let i = 0; i < this._renderObjects.length; ++i) {\r\n            const renderingObject = this._renderObjects[i];\r\n            renderingObject.object.useVelocity =\r\n                renderingObject.targetRenderer.useVelocity;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _prepareRendering(): void {\r\n        let needInitialization = false;\r\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\r\n            needInitialization =\r\n                needInitialization ||\r\n                this._targetRenderers[i].needInitialization;\r\n        }\r\n        if (needInitialization) {\r\n            this._initialize();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _render(forCamera?: BABYLON.Camera): void {\r\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\r\n            if (!forCamera || this._targetRenderers[i].camera === forCamera) {\r\n                this._targetRenderers[i].clearTargets();\r\n            }\r\n        }\r\n\r\n        for (const [camera, list] of this._cameras) {\r\n            if (forCamera && camera !== forCamera) {\r\n                continue;\r\n            }\r\n\r\n            const firstPostProcess = camera._getFirstPostProcess();\r\n            if (!firstPostProcess) {\r\n                continue;\r\n            }\r\n\r\n            const sourceCopyDepth =\r\n                firstPostProcess.inputTexture?.depthStencilTexture;\r\n            if (sourceCopyDepth) {\r\n                const [targetRenderers, copyDepthTextures] = list;\r\n                for (const targetRenderer of targetRenderers) {\r\n                    targetRenderer._bgDepthTexture = sourceCopyDepth;\r\n                }\r\n                for (const key in copyDepthTextures) {\r\n                    copyDepthTextures[key].copy(sourceCopyDepth);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this._renderObjects.length; ++i) {\r\n            const renderingObject = this._renderObjects[i];\r\n            if (\r\n                !forCamera ||\r\n                renderingObject.targetRenderer.camera === forCamera\r\n            ) {\r\n                renderingObject.targetRenderer.render(renderingObject.object);\r\n            }\r\n        }\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\r\n        this._onEngineResizeObserver = null;\r\n\r\n        for (let i = 0; i < this._renderObjects.length; ++i) {\r\n            this._renderObjects[i].object.dispose();\r\n        }\r\n\r\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\r\n            this._targetRenderers[i].dispose();\r\n        }\r\n\r\n        for (const key of this._cameras) {\r\n            const copyDepthTextures = key[1][1];\r\n            for (const key in copyDepthTextures) {\r\n                copyDepthTextures[key].dispose();\r\n            }\r\n        }\r\n\r\n        this._renderObjects = [];\r\n        this._targetRenderers = [];\r\n        this._cameras.clear();\r\n    }\r\n}\r\n\r\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleDepthVertexShader\"] =\r\n    particleDepthVertex;\r\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleDepthFragmentShader\"] =\r\n    particleDepthFragment;\r\n\r\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleThicknessVertexShader\"] =\r\n    particleThicknessVertex;\r\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleThicknessFragmentShader\"] =\r\n    particleThicknessFragment;\r\n\r\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleDiffuseVertexShader\"] =\r\n    particleDiffuseVertex;\r\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleDiffuseFragmentShader\"] =\r\n    particleDiffuseFragment;\r\n\r\nBABYLON.ShaderStore.ShadersStore[\"bilateralBlurFragmentShader\"] =\r\n    bilateralBlurFragment;\r\n\r\nBABYLON.ShaderStore.ShadersStore[\"standardBlurFragmentShader\"] =\r\n    standardBlurFragment;\r\n\r\nBABYLON.ShaderStore.ShadersStore[\"renderFluidFragmentShader\"] =\r\n    renderFluidFragment;\r\nBABYLON.ShaderStore.ShadersStoreWGSL[\"renderFluidFragmentShader\"] =\r\n    renderFluidWGSLFragment;\r\n\r\nBABYLON.ShaderStore.ShadersStore[\"passDepthVertexShader\"] = passDepthVertex;\r\nBABYLON.ShaderStore.ShadersStore[\"passDepthFragmentShader\"] = passDepthFragment;\r\n\r\nBABYLON.ShaderStore.ShadersStoreWGSL[\"passDepthVertexShader\"] =\r\n    passDepthWGSLVertex;\r\nBABYLON.ShaderStore.ShadersStoreWGSL[\"passDepthFragmentShader\"] =\r\n    passDepthWGSLFragment;\r\n\r\nBABYLON.ShaderStore.ShadersStoreWGSL[\"postprocessVertexShader\"] =\r\n    postprocessWGSLVertex;\r\n","export default \"attribute vec3 position;\\r\\nattribute vec2 offset;\\r\\n\\r\\nuniform mat4 view;\\r\\nuniform mat4 projection;\\r\\nuniform vec2 size;\\r\\n\\r\\nvarying vec2 uv;\\r\\nvarying vec3 viewPos;\\r\\nvarying float sphereRadius;\\r\\n\\r\\n#ifdef FLUIDRENDERING_VELOCITY\\r\\n    attribute vec3 velocity;\\r\\n    varying float velocityNorm;\\r\\n#endif\\r\\n\\r\\nvoid main(void) {\\r\\n    vec3 cornerPos;\\r\\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\\r\\n    cornerPos.z = 0.0;\\r\\n\\r\\n    viewPos = (view * vec4(position, 1.0)).xyz;\\r\\n\\r\\n    gl_Position = projection * vec4(viewPos + cornerPos, 1.0);\\r\\n\\r\\n    uv = offset;\\r\\n    sphereRadius = size.x / 2.0;\\r\\n#ifdef FLUIDRENDERING_VELOCITY\\r\\n    velocityNorm = length(velocity);\\r\\n#endif\\r\\n}\\r\\n\";","export default \"uniform mat4 projection;\\r\\n\\r\\nvarying vec2 uv;\\r\\nvarying vec3 viewPos;\\r\\nvarying float sphereRadius;\\r\\n\\r\\n#ifdef FLUIDRENDERING_VELOCITY\\r\\n    varying float velocityNorm;\\r\\n#endif\\r\\n\\r\\nvoid main(void) {\\r\\n    vec3 normal;\\r\\n\\r\\n    normal.xy = uv * 2.0 - 1.0;\\r\\n    float r2 = dot(normal.xy, normal.xy);\\r\\n    if (r2 > 1.0) discard;\\r\\n    normal.z = -sqrt(1.0 - r2);\\r\\n\\r\\n    vec4 realViewPos = vec4(viewPos + normal * sphereRadius, 1.0);\\r\\n    vec4 clipSpacePos = projection * realViewPos;\\r\\n\\r\\n#ifdef WEBGPU\\r\\n    gl_FragDepth = clipSpacePos.z / clipSpacePos.w;\\r\\n#else\\r\\n    gl_FragDepth = (clipSpacePos.z / clipSpacePos.w) * 0.5 + 0.5;\\r\\n#endif\\r\\n\\r\\n#ifdef FLUIDRENDERING_VELOCITY\\r\\n    glFragColor = vec4(realViewPos.z, velocityNorm, 0., 1.);\\r\\n#else\\r\\n    glFragColor = vec4(realViewPos.z, 0., 0., 1.);\\r\\n#endif\\r\\n}\\r\\n\";","export default \"attribute vec3 position;\\r\\nattribute vec2 offset;\\r\\n\\r\\nuniform mat4 view;\\r\\nuniform mat4 projection;\\r\\nuniform vec2 size;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nvoid main(void) {\\r\\n    vec3 cornerPos;\\r\\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\\r\\n    cornerPos.z = 0.0;\\r\\n\\r\\n    vec3 viewPos = (view * vec4(position, 1.0)).xyz + cornerPos;\\r\\n\\r\\n    gl_Position = projection * vec4(viewPos, 1.0);\\r\\n\\r\\n    uv = offset;\\r\\n}\\r\\n\";","export default \"uniform float particleAlpha;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nvoid main(void) {\\r\\n    vec3 normal;\\r\\n\\r\\n    normal.xy = uv * 2.0 - 1.0;\\r\\n    float r2 = dot(normal.xy, normal.xy);\\r\\n    if (r2 > 1.0) discard;\\r\\n    float thickness = sqrt(1.0 - r2);\\r\\n\\r\\n    glFragColor = vec4(vec3(particleAlpha * thickness), 1.0);\\r\\n}\\r\\n\";","export default \"attribute vec3 position;\\r\\nattribute vec2 offset;\\r\\nattribute vec4 color;\\r\\n\\r\\nuniform mat4 view;\\r\\nuniform mat4 projection;\\r\\nuniform vec2 size;\\r\\n\\r\\nvarying vec2 uv;\\r\\nvarying vec3 diffuseColor;\\r\\n\\r\\nvoid main(void) {\\r\\n    vec3 cornerPos;\\r\\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\\r\\n    cornerPos.z = 0.0;\\r\\n\\r\\n    vec3 viewPos = (view * vec4(position, 1.0)).xyz + cornerPos;\\r\\n\\r\\n    gl_Position = projection * vec4(viewPos, 1.0);\\r\\n\\r\\n    uv = offset;\\r\\n    diffuseColor = color.rgb;\\r\\n}\\r\\n\";","export default \"uniform float particleAlpha;\\r\\n\\r\\nvarying vec2 uv;\\r\\nvarying vec3 diffuseColor;\\r\\n\\r\\nvoid main(void) {\\r\\n    vec3 normal;\\r\\n\\r\\n    normal.xy = uv * 2.0 - 1.0;\\r\\n    float r2 = dot(normal.xy, normal.xy);\\r\\n    if (r2 > 1.0) discard;\\r\\n\\r\\n    glFragColor = vec4(diffuseColor, 1.0);\\r\\n}\\r\\n\";","export default \"uniform sampler2D textureSampler;\\r\\n\\r\\nuniform int maxFilterSize;\\r\\nuniform vec2 blurDir;\\r\\nuniform float projectedParticleConstant;\\r\\nuniform float depthThreshold;\\r\\n\\r\\nvarying vec2 vUV;\\r\\n\\r\\nvoid main(void) {\\r\\n    float depth = texture2D(textureSampler, vUV).x;\\r\\n\\r\\n    if (depth >= 1e6 || depth <= 0.) {\\r\\n        glFragColor = vec4(vec3(depth), 1.);\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    int filterSize = min(maxFilterSize, int(ceil(projectedParticleConstant / depth)));\\r\\n    float sigma = float(filterSize) / 3.0;\\r\\n    float two_sigma2 = 2.0 * sigma * sigma;\\r\\n\\r\\n    float sigmaDepth = depthThreshold / 3.0;\\r\\n    float two_sigmaDepth2 = 2.0 * sigmaDepth * sigmaDepth;\\r\\n\\r\\n    float sum = 0.;\\r\\n    float wsum = 0.;\\r\\n    float sumVel = 0.;\\r\\n\\r\\n    for (int x = -filterSize; x <= filterSize; ++x) {\\r\\n        vec2 coords = vec2(x);\\r\\n        vec2 sampleDepthVel = texture2D(textureSampler, vUV + coords * blurDir).rg;\\r\\n\\r\\n        float r = dot(coords, coords);\\r\\n        float w = exp(-r / two_sigma2);\\r\\n\\r\\n        float rDepth = sampleDepthVel.r - depth;\\r\\n        float wd = exp(-rDepth * rDepth / two_sigmaDepth2);\\r\\n\\r\\n        sum += sampleDepthVel.r * w * wd;\\r\\n        sumVel += sampleDepthVel.g * w * wd;\\r\\n        wsum += w * wd;\\r\\n    }\\r\\n\\r\\n    glFragColor = vec4(sum / wsum, sumVel / wsum, 0., 1.);\\r\\n}\\r\\n\";","export default \"uniform sampler2D textureSampler;\\r\\n\\r\\nuniform int filterSize;\\r\\nuniform vec2 blurDir;\\r\\n\\r\\nvarying vec2 vUV;\\r\\n\\r\\nvoid main(void) {\\r\\n    vec4 s = texture2D(textureSampler, vUV);\\r\\n    if (s.r == 0.) {\\r\\n        glFragColor = vec4(0., 0., 0., 1.);\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    float sigma = float(filterSize) / 3.0;\\r\\n    float twoSigma2 = 2.0 * sigma * sigma;\\r\\n\\r\\n    vec4 sum = vec4(0.);\\r\\n    float wsum = 0.;\\r\\n\\r\\n    for (int x = -filterSize; x <= filterSize; ++x) {\\r\\n        vec2 coords = vec2(x);\\r\\n        vec4 sampl = texture2D(textureSampler, vUV + coords * blurDir);\\r\\n\\r\\n        float w = exp(-coords.x * coords.x / twoSigma2);\\r\\n\\r\\n        sum += sampl * w;\\r\\n        wsum += w;\\r\\n    }\\r\\n\\r\\n    sum /= wsum;\\r\\n\\r\\n    glFragColor = vec4(sum.rgb, 1.);\\r\\n}\\r\\n\";","export default \"// Index of refraction for water\\r\\n#define IOR 1.333\\r\\n\\r\\n// Ratios of air and water IOR for refraction\\r\\n// Air to water\\r\\n#define ETA 1.0/IOR\\r\\n\\r\\n// Fresnel at 0°\\r\\n#define F0 0.02\\r\\n\\r\\nuniform sampler2D textureSampler;\\r\\nuniform sampler2D depthSampler;\\r\\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\\r\\n    uniform sampler2D diffuseSampler;\\r\\n#else\\r\\n    uniform vec3 diffuseColor;\\r\\n#endif\\r\\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\\r\\n    uniform float thickness;\\r\\n    uniform sampler2D bgDepthSampler;\\r\\n#else\\r\\n    uniform float minimumThickness;\\r\\n    uniform sampler2D thicknessSampler;\\r\\n#endif\\r\\nuniform samplerCube reflectionSampler;\\r\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\\r\\n    uniform sampler2D debugSampler;\\r\\n#endif\\r\\n\\r\\nuniform mat4 viewMatrix;\\r\\nuniform mat4 projectionMatrix;\\r\\nuniform mat4 invProjectionMatrix;\\r\\nuniform vec2 texelSize;\\r\\nuniform vec3 dirLight;\\r\\nuniform float cameraFar;\\r\\nuniform float density;\\r\\nuniform float refractionStrength;\\r\\nuniform float fresnelClamp;\\r\\nuniform float specularPower;\\r\\n\\r\\nvarying vec2 vUV;\\r\\n\\r\\nvec3 computeViewPosFromUVDepth(vec2 texCoord, float depth) {\\r\\n    vec4 ndc;\\r\\n    \\r\\n    ndc.xy = texCoord * 2.0 - 1.0;\\r\\n    ndc.z = projectionMatrix[2].z + projectionMatrix[3].z / depth;\\r\\n    ndc.w = 1.0;\\r\\n\\r\\n    vec4 eyePos = invProjectionMatrix * ndc;\\r\\n    eyePos.xyz /= eyePos.w;\\r\\n\\r\\n    return eyePos.xyz;\\r\\n}\\r\\n\\r\\nvec3 getViewPosFromTexCoord(vec2 texCoord) {\\r\\n    float depth = texture2D(depthSampler, texCoord).x;\\r\\n    return computeViewPosFromUVDepth(texCoord, depth);\\r\\n}\\r\\n\\r\\nvoid main(void) {\\r\\n    vec2 texCoord = vUV;\\r\\n\\r\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\\r\\n    vec4 color = texture2D(debugSampler, texCoord);\\r\\n    #ifdef FLUIDRENDERING_DEBUG_DEPTH\\r\\n        glFragColor = vec4(color.rgb / vec3(2.0), 1.);\\r\\n        if (color.r > 0.999 && color.g > 0.999) {\\r\\n            glFragColor = texture2D(textureSampler, texCoord);\\r\\n        }\\r\\n    #else\\r\\n        glFragColor = vec4(color.rgb, 1.);\\r\\n        if (color.r < 0.001 && color.g < 0.001 && color.b < 0.001) {\\r\\n            glFragColor = texture2D(textureSampler, texCoord);\\r\\n        }\\r\\n    #endif\\r\\n    return;\\r\\n#endif\\r\\n\\r\\n    vec2 depthVel = texture2D(depthSampler, texCoord).rg;\\r\\n    float depth = depthVel.r;\\r\\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\\r\\n    float thickness = texture2D(thicknessSampler, texCoord).x;\\r\\n#else\\r\\n    float bgDepth = texture2D(bgDepthSampler, texCoord).x;\\r\\n    float depthNonLinear = projectionMatrix[2].z + projectionMatrix[3].z / depth;\\r\\n    depthNonLinear = depthNonLinear * 0.5 + 0.5;\\r\\n#endif\\r\\n\\r\\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\\r\\n    if (depth >= cameraFar || depth <= 0. || thickness <= minimumThickness) {\\r\\n#else\\r\\n    if (depth >= cameraFar || depth <= 0. || bgDepth <= depthNonLinear) {\\r\\n#endif\\r\\n        vec3 backColor = texture2D(textureSampler, texCoord).rgb;\\r\\n        glFragColor = vec4(backColor, 1.);\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    // calculate view-space position from depth\\r\\n    vec3 viewPos = computeViewPosFromUVDepth(texCoord, depth);\\r\\n\\r\\n    // calculate normal\\r\\n    vec3 ddx = getViewPosFromTexCoord(texCoord + vec2(texelSize.x, 0.)) - viewPos;\\r\\n    vec3 ddy = getViewPosFromTexCoord(texCoord + vec2(0., texelSize.y)) - viewPos;\\r\\n\\r\\n    vec3 ddx2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(-texelSize.x, 0.));\\r\\n    if (abs(ddx.z) > abs(ddx2.z)) {\\r\\n        ddx = ddx2;\\r\\n    }\\r\\n\\r\\n    vec3 ddy2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(0., -texelSize.y));\\r\\n    if (abs(ddy.z) > abs(ddy2.z)) {\\r\\n        ddy = ddy2;\\r\\n    }\\r\\n\\r\\n    vec3 normal = normalize(cross(ddy, ddx));\\r\\n    if(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) ||\\r\\n    isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {\\r\\n        normal = vec3(0., 0., -1.);\\r\\n    }\\r\\n\\r\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\\r\\n    glFragColor = vec4(normal * 0.5 + 0.5, 1.0);\\r\\n    return;\\r\\n#endif\\r\\n\\r\\n    // shading\\r\\n    vec3 rayDir = normalize(viewPos); // direction from camera position to view position\\r\\n\\r\\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\\r\\n    vec3 diffuseColor = texture2D(diffuseSampler, texCoord).rgb;\\r\\n#endif\\r\\n\\r\\n    vec3  lightDir = normalize(vec3(viewMatrix * vec4(-dirLight, 0.)));\\r\\n    vec3  H        = normalize(lightDir - rayDir);\\r\\n    float specular = pow(max(0.0, dot(H, normal)), specularPower);\\r\\n\\r\\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\\r\\n    float diffuse  = max(0.0, dot(lightDir, normal)) * 1.0;\\r\\n\\r\\n    glFragColor = vec4(vec3(0.1) /*ambient*/ + vec3(0.42, 0.50, 1.00) * diffuse + vec3(0, 0, 0.2) + specular, 1.);\\r\\n    return;\\r\\n#endif\\r\\n\\r\\n    // Refraction color\\r\\n    vec3 refractionDir = refract(rayDir, normal, ETA);\\r\\n\\r\\n    vec3 transmitted = (texture2D(textureSampler, vec2(texCoord + refractionDir.xy * thickness * refractionStrength)).rgb);\\r\\n    vec3 transmittance = exp(-density * thickness * (1.0 - diffuseColor)); // Beer law\\r\\n   \\r\\n    vec3 refractionColor = transmitted * transmittance;\\r\\n\\r\\n    // Reflection of the environment.\\r\\n    vec3 reflectionDir = reflect(rayDir, normal);\\r\\n    vec3 reflectionColor = (textureCube(reflectionSampler, reflectionDir).rgb);\\r\\n\\r\\n    // Combine refraction and reflection    \\r\\n    float fresnel = clamp(F0 + (1.0 - F0) * pow(1.0 - dot(normal, -rayDir), 5.0), 0., fresnelClamp);\\r\\n    \\r\\n    vec3 finalColor = mix(refractionColor, reflectionColor, fresnel) + specular;\\r\\n\\r\\n#ifdef FLUIDRENDERING_VELOCITY\\r\\n    float velocity = depthVel.g;\\r\\n    finalColor = mix(finalColor, vec3(1.0), smoothstep(0.3, 1.0, velocity / 6.0));\\r\\n#endif\\r\\n\\r\\n    glFragColor = vec4(finalColor, 1.);\\r\\n}\\r\\n\";","export default \"// Index of refraction for water\\r\\nlet IOR = 1.333;\\r\\n\\r\\n// Ratios of air and water IOR for refraction\\r\\n// Air to water\\r\\nlet ETA = 0.7501875468867217; // 1.0 / IOR;\\r\\n\\r\\n// Fresnel at 0°\\r\\nlet F0 = 0.02;\\r\\n\\r\\nvar textureSampler : texture_2d<f32>;\\r\\nvar textureSamplerSampler : sampler;\\r\\nvar depthSampler : texture_2d<f32>;\\r\\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\\r\\n    var diffuseSampler : texture_2d<f32>;\\r\\n    var diffuseSamplerSampler : sampler;\\r\\n#else\\r\\n    uniform diffuseColor : vec3<f32>;\\r\\n#endif\\r\\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\\r\\n    uniform thickness : f32;\\r\\n    var bgDepthSampler: texture_depth_2d;\\r\\n    var bgDepthSamplerSampler: sampler;\\r\\n#else\\r\\n    uniform minimumThickness : f32;\\r\\n    var thicknessSampler : texture_2d<f32>;\\r\\n    var thicknessSamplerSampler : sampler;\\r\\n#endif\\r\\nvar reflectionSampler : texture_cube<f32>;\\r\\nvar reflectionSamplerSampler : sampler;\\r\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\\r\\n    var debugSampler : texture_2d<f32>;\\r\\n    var debugSamplerSampler : sampler;\\r\\n#endif\\r\\n\\r\\nuniform viewMatrix : mat4x4<f32>;\\r\\nuniform projectionMatrix : mat4x4<f32>;\\r\\nuniform invProjectionMatrix : mat4x4<f32>;\\r\\nuniform texelSize : vec2<f32>;\\r\\nuniform dirLight : vec3<f32>;\\r\\nuniform cameraFar : f32;\\r\\nuniform density : f32;\\r\\nuniform refractionStrength : f32;\\r\\nuniform fresnelClamp : f32;\\r\\nuniform specularPower : f32;\\r\\n\\r\\nvarying vUV : vec2<f32>;\\r\\n\\r\\nfn computeViewPosFromUVDepth(texCoord : vec2<f32>, depth : f32) -> vec3<f32> {\\r\\n    let ndc = vec4(texCoord * 2.0 - 1.0, uniforms.projectionMatrix[2].z + uniforms.projectionMatrix[3].z / depth, 1.0);\\r\\n\\r\\n    var eyePos = uniforms.invProjectionMatrix * ndc;\\r\\n\\r\\n    return eyePos.xyz / eyePos.w;\\r\\n}\\r\\n\\r\\nfn getViewPosFromTexCoord(texCoord : vec2<f32>) -> vec3<f32> {\\r\\n    let dim = textureDimensions(depthSampler);\\r\\n    let depth = textureLoad(depthSampler, vec2<i32>(texCoord * vec2<f32>(dim)), 0).x;\\r\\n    return computeViewPosFromUVDepth(texCoord, depth);\\r\\n}\\r\\n\\r\\n@stage(fragment)\\r\\nfn main(input: FragmentInputs) -> FragmentOutputs {\\r\\n    let texCoord = vUV;\\r\\n\\r\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\\r\\n    #ifdef FLUIDRENDERING_DEBUG_DEPTH\\r\\n        let dim2 = textureDimensions(debugSampler);\\r\\n        let color = textureLoad(debugSampler, vec2<i32>(texCoord * vec2<f32>(dim2)), 0);\\r\\n        gl_FragColor = vec4(color.rgb / 2.0, 1.);\\r\\n        if (color.r > 0.999 && color.g > 0.999) {\\r\\n            gl_FragColor = textureSample(textureSampler, textureSamplerSampler, texCoord);\\r\\n        }\\r\\n    #else\\r\\n        let color = textureSample(debugSampler, debugSamplerSampler, texCoord);\\r\\n        gl_FragColor = vec4(color.rgb, 1.);\\r\\n        if (color.r < 0.001 && color.g < 0.001 && color.b < 0.001) {\\r\\n            gl_FragColor = textureSample(textureSampler, textureSamplerSampler, texCoord);\\r\\n        }\\r\\n    #endif\\r\\n    output.color = gl_FragColor;\\r\\n    return output;\\r\\n#endif\\r\\n\\r\\n    let dim = textureDimensions(depthSampler);\\r\\n    let depthVel = textureLoad(depthSampler, vec2<i32>(texCoord * vec2<f32>(dim)), 0).rg;\\r\\n    let depth = depthVel.r;\\r\\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\\r\\n    let thickness_ = textureSample(thicknessSampler, thicknessSamplerSampler, texCoord).x;\\r\\n#else\\r\\n    let bgDepth = textureSample(bgDepthSampler, bgDepthSamplerSampler, texCoord);\\r\\n    let depthNonLinear = uniforms.projectionMatrix[2].z + uniforms.projectionMatrix[3].z / depth;\\r\\n    let thickness_ = uniforms.thickness;\\r\\n#endif\\r\\n    let thickness = thickness_;\\r\\n\\r\\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\\r\\n    if (depth >= uniforms.cameraFar || depth <= 0. || thickness <= uniforms.minimumThickness) {\\r\\n#else\\r\\n    if (depth >= uniforms.cameraFar || depth <= 0. || bgDepth <= depthNonLinear) {\\r\\n#endif\\r\\n        let backColor = textureSample(textureSampler, textureSamplerSampler, texCoord).rgb;\\r\\n        gl_FragColor = vec4(backColor, 1.);\\r\\n        output.color = gl_FragColor;\\r\\n        return output;\\r\\n    }\\r\\n\\r\\n    // calculate view-space position from depth\\r\\n    let viewPos = computeViewPosFromUVDepth(texCoord, depth);\\r\\n\\r\\n    // calculate normal\\r\\n    var ddx = getViewPosFromTexCoord(texCoord + vec2(uniforms.texelSize.x, 0.)) - viewPos;\\r\\n    var ddy = getViewPosFromTexCoord(texCoord + vec2(0., uniforms.texelSize.y)) - viewPos;\\r\\n\\r\\n    let ddx2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(-uniforms.texelSize.x, 0.));\\r\\n    if (abs(ddx.z) > abs(ddx2.z)) {\\r\\n        ddx = ddx2;\\r\\n    }\\r\\n\\r\\n    let ddy2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(0., -uniforms.texelSize.y));\\r\\n    if (abs(ddy.z) > abs(ddy2.z)) {\\r\\n        ddy = ddy2;\\r\\n    }\\r\\n\\r\\n    let normal = normalize(cross(ddy, ddx));\\r\\n\\r\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\\r\\n    gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);\\r\\n    output.color = gl_FragColor;\\r\\n    return output;\\r\\n#endif\\r\\n\\r\\n    // shading\\r\\n    let rayDir = normalize(viewPos); // direction from camera position to view position\\r\\n\\r\\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\\r\\n    let diffuseColor_ = textureSample(diffuseSampler, diffuseSamplerSampler, texCoord).rgb;\\r\\n#else\\r\\n    let diffuseColor_ = uniforms.diffuseColor;\\r\\n#endif\\r\\n    let diffuseColor = diffuseColor_;\\r\\n\\r\\n    let  lightDir = normalize((uniforms.viewMatrix * vec4(-uniforms.dirLight, 0.)).xyz);\\r\\n    let  H        = normalize(lightDir - rayDir);\\r\\n    let specular = pow(max(0.0, dot(H, normal)), uniforms.specularPower);\\r\\n\\r\\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\\r\\n    let diffuse  = max(0.0, dot(lightDir, normal)) * 1.0;\\r\\n\\r\\n    gl_FragColor = vec4(vec3(0.1) + vec3(0.42, 0.50, 1.00) * diffuse + vec3(0, 0, 0.2) + specular, 1.);\\r\\n    output.color = gl_FragColor;\\r\\n    return output;\\r\\n#endif\\r\\n\\r\\n    // Refraction color\\r\\n    let refractionDir = refract(rayDir, normal, ETA);\\r\\n\\r\\n    let transmitted = (textureSample(textureSampler, textureSamplerSampler, vec2(texCoord + refractionDir.xy * thickness * uniforms.refractionStrength)).rgb);\\r\\n    let transmittance = exp(-uniforms.density * thickness * (1.0 - diffuseColor)); // Beer law\\r\\n   \\r\\n    let refractionColor = transmitted * transmittance;\\r\\n\\r\\n    // Reflection of the environment.\\r\\n    let reflectionDir = reflect(rayDir, normal);\\r\\n    let reflectionColor = textureSample(reflectionSampler, reflectionSamplerSampler, reflectionDir).rgb;\\r\\n\\r\\n    // Combine refraction and reflection    \\r\\n    let fresnel = clamp(F0 + (1.0 - F0) * pow(1.0 - dot(normal, -rayDir), 5.0), 0., uniforms.fresnelClamp);\\r\\n    \\r\\n    var finalColor = mix(refractionColor, reflectionColor, fresnel) + specular;\\r\\n\\r\\n#ifdef FLUIDRENDERING_VELOCITY\\r\\n    let velocity = depthVel.g;\\r\\n    finalColor = mix(finalColor, vec3(1.0), smoothstep(0.3, 1.0, velocity / 6.0));\\r\\n#endif\\r\\n\\r\\n    gl_FragColor = vec4(finalColor, 1.);\\r\\n}\\r\\n\";","export default \"attribute vec2 position;\\r\\n\\r\\nvarying vec2 vUV;\\r\\n\\r\\nconst vec2 madd = vec2(0.5, 0.5);\\r\\n\\r\\nvoid main(void) {\\r\\n\\tvUV = position * madd + madd;\\r\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\r\\n}\\r\\n\";","export default \"uniform sampler2D textureDepth;\\r\\n\\r\\nvarying vec2 vUV;\\r\\n\\r\\nvoid main(void) \\r\\n{\\r\\n\\tgl_FragDepth = texture2D(textureDepth, vUV).x;\\r\\n}\\r\\n\";","export default \"attribute position: vec2<f32>;\\r\\n\\r\\nvarying vUV: vec2<f32>;\\r\\n\\r\\nlet madd = vec2(0.5, 0.5);\\r\\n\\r\\n@stage(vertex)\\r\\nfn main(input : VertexInputs) -> FragmentInputs\\r\\n{\\r\\n\\tvUV = position * madd + madd;\\r\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\r\\n}\\r\\n\";","export default \"var textureDepth: texture_depth_2d;\\r\\nvar textureDepthSampler: sampler;\\r\\n\\r\\nvarying vUV: vec2<f32>;\\r\\n\\r\\n@stage(fragment)\\r\\nfn main(input: FragmentInputs) -> FragmentOutputs\\r\\n{\\r\\n\\tgl_FragDepth = textureSample(textureDepth, textureDepthSampler, vUV);\\r\\n}\\r\\n\";","export default \"// Attributes\\r\\nattribute position : vec2<f32>;\\r\\n\\r\\nuniform scale : vec2<f32>;\\r\\n// Output\\r\\nvarying vUV : vec2<f32>;\\r\\n\\r\\nlet madd = vec2(0.5, 0.5);\\r\\n\\r\\n#define CUSTOM_VERTEX_DEFINITIONS\\r\\n\\r\\n@stage(vertex)\\r\\nfn main(input : VertexInputs) -> FragmentInputs\\r\\n{\\r\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\r\\n\\r\\n\\tvUV = (position * madd + madd) * uniforms.scale;\\r\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\r\\n\\r\\n#define CUSTOM_VERTEX_MAIN_END\\r\\n}\\r\\n\";","import * as BABYLON from \"@babylonjs/core\";\r\n\r\nexport abstract class FluidRenderingObject {\r\n    protected _scene: BABYLON.Scene;\r\n    protected _engine: BABYLON.Engine;\r\n    protected _effectsAreDirty: boolean;\r\n    protected _depthEffectWrapper: BABYLON.Nullable<BABYLON.EffectWrapper>;\r\n    protected _thicknessEffectWrapper: BABYLON.Nullable<BABYLON.EffectWrapper>;\r\n\r\n    public priority = 0;\r\n\r\n    protected _particleSize = 0.1;\r\n\r\n    public onParticleSizeChanged =\r\n        new BABYLON.Observable<FluidRenderingObject>();\r\n\r\n    public get particleSize() {\r\n        return this._particleSize;\r\n    }\r\n\r\n    public set particleSize(size: number) {\r\n        if (size === this._particleSize) {\r\n            return;\r\n        }\r\n\r\n        this._particleSize = size;\r\n        this.onParticleSizeChanged.notifyObservers(this);\r\n    }\r\n\r\n    public particleThicknessAlpha = 0.05;\r\n\r\n    public get useInstancing() {\r\n        return !this.indexBuffer;\r\n    }\r\n\r\n    private _useVelocity = false;\r\n\r\n    public get useVelocity() {\r\n        return this._useVelocity;\r\n    }\r\n\r\n    public set useVelocity(use: boolean) {\r\n        if (this._useVelocity === use || !this._hasVelocity()) {\r\n            return;\r\n        }\r\n\r\n        this._useVelocity = use;\r\n        this._effectsAreDirty = true;\r\n    }\r\n\r\n    private _hasVelocity() {\r\n        return !!this.vertexBuffers.velocity;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FluidRenderingObject\";\r\n    }\r\n\r\n    constructor(\r\n        scene: BABYLON.Scene,\r\n        public readonly vertexBuffers: { [key: string]: BABYLON.VertexBuffer },\r\n        public readonly indexBuffer: BABYLON.Nullable<BABYLON.DataBuffer>\r\n    ) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._effectsAreDirty = true;\r\n        this._depthEffectWrapper = null;\r\n        this._thicknessEffectWrapper = null;\r\n    }\r\n\r\n    protected _createEffects(): void {\r\n        const uniformNames = [\"view\", \"projection\", \"particleRadius\", \"size\"];\r\n        const attributeNames = [\"position\", \"offset\"];\r\n        const defines: string[] = [];\r\n\r\n        this._effectsAreDirty = false;\r\n\r\n        if (this.useVelocity) {\r\n            attributeNames.push(\"velocity\");\r\n            defines.push(\"#define FLUIDRENDERING_VELOCITY\");\r\n        }\r\n\r\n        this._depthEffectWrapper = new BABYLON.EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"fluidParticleDepth\",\r\n            fragmentShader: \"fluidParticleDepth\",\r\n            attributeNames,\r\n            uniformNames,\r\n            samplerNames: [],\r\n            defines,\r\n        });\r\n\r\n        uniformNames.push(\"particleAlpha\");\r\n\r\n        this._thicknessEffectWrapper = new BABYLON.EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"fluidParticleThickness\",\r\n            fragmentShader: \"fluidParticleThickness\",\r\n            attributeNames: [\"position\", \"offset\"],\r\n            uniformNames,\r\n            samplerNames: [],\r\n        });\r\n    }\r\n\r\n    public isReady(): boolean {\r\n        if (this._effectsAreDirty) {\r\n            this._createEffects();\r\n        }\r\n\r\n        if (!this._depthEffectWrapper || !this._thicknessEffectWrapper) {\r\n            return false;\r\n        }\r\n\r\n        const depthEffect = this._depthEffectWrapper._drawWrapper.effect!;\r\n        const thicknessEffect =\r\n            this._thicknessEffectWrapper._drawWrapper.effect!;\r\n\r\n        return depthEffect.isReady() && thicknessEffect.isReady();\r\n    }\r\n\r\n    public numParticles(): number {\r\n        return 0;\r\n    }\r\n\r\n    public renderDepthTexture(): void {\r\n        const numParticles = this.numParticles();\r\n\r\n        if (!this._depthEffectWrapper || numParticles === 0) {\r\n            return;\r\n        }\r\n\r\n        const depthDrawWrapper = this._depthEffectWrapper._drawWrapper;\r\n        const depthEffect = depthDrawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(depthDrawWrapper);\r\n        this._engine.bindBuffers(\r\n            this.vertexBuffers,\r\n            this.indexBuffer,\r\n            depthEffect\r\n        );\r\n\r\n        depthEffect.setMatrix(\"view\", this._scene.getViewMatrix());\r\n        depthEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n        depthEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\r\n        depthEffect.setFloat(\"particleRadius\", this._particleSize / 2);\r\n\r\n        if (this.useInstancing) {\r\n            this._engine.drawArraysType(\r\n                BABYLON.Constants.MATERIAL_TriangleStripDrawMode,\r\n                0,\r\n                4,\r\n                numParticles\r\n            );\r\n        } else {\r\n            this._engine.drawElementsType(\r\n                BABYLON.Constants.MATERIAL_TriangleFillMode,\r\n                0,\r\n                numParticles\r\n            );\r\n        }\r\n    }\r\n\r\n    public renderThicknessTexture(): void {\r\n        const numParticles = this.numParticles();\r\n\r\n        if (!this._thicknessEffectWrapper || numParticles === 0) {\r\n            return;\r\n        }\r\n\r\n        const thicknessDrawWrapper = this._thicknessEffectWrapper._drawWrapper;\r\n        const thicknessEffect = thicknessDrawWrapper.effect!;\r\n\r\n        this._engine.setAlphaMode(BABYLON.Constants.ALPHA_ONEONE);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        this._engine.enableEffect(thicknessDrawWrapper);\r\n        this._engine.bindBuffers(\r\n            this.vertexBuffers,\r\n            this.indexBuffer,\r\n            thicknessEffect\r\n        );\r\n\r\n        thicknessEffect.setMatrix(\"view\", this._scene.getViewMatrix());\r\n        thicknessEffect.setMatrix(\r\n            \"projection\",\r\n            this._scene.getProjectionMatrix()\r\n        );\r\n        thicknessEffect.setFloat(\"particleAlpha\", this.particleThicknessAlpha);\r\n        thicknessEffect.setFloat2(\r\n            \"size\",\r\n            this._particleSize,\r\n            this._particleSize\r\n        );\r\n\r\n        if (this.useInstancing) {\r\n            this._engine.drawArraysType(\r\n                BABYLON.Constants.MATERIAL_TriangleStripDrawMode,\r\n                0,\r\n                4,\r\n                numParticles\r\n            );\r\n        } else {\r\n            this._engine.drawElementsType(\r\n                BABYLON.Constants.MATERIAL_TriangleFillMode,\r\n                0,\r\n                numParticles\r\n            );\r\n        }\r\n\r\n        this._engine.setDepthWrite(true);\r\n        this._engine.setAlphaMode(BABYLON.Constants.ALPHA_DISABLE);\r\n    }\r\n\r\n    public renderDiffuseTexture(): void {\r\n        // do nothing by default\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._depthEffectWrapper?.dispose();\r\n        this._thicknessEffectWrapper?.dispose();\r\n    }\r\n}\r\n","import * as BABYLON from \"@babylonjs/core\";\r\n\r\nimport { FluidRenderingObject } from \"./fluidRenderingObject\";\r\n\r\nexport class FluidRenderingObjectParticleSystem extends FluidRenderingObject {\r\n    private _particleSystem: BABYLON.ParticleSystem;\r\n    private _renderCallback: () => number;\r\n    private _blendMode: number;\r\n    private _onBeforeDrawParticleObserver: BABYLON.Nullable<\r\n        BABYLON.Observer<BABYLON.Nullable<BABYLON.Effect>>\r\n    >;\r\n\r\n    public get particleSystem() {\r\n        return this._particleSystem;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FluidRenderingObjectParticleSystem\";\r\n    }\r\n\r\n    private _useTrueRenderingForDiffuseTexture = true;\r\n\r\n    public get useTrueRenderingForDiffuseTexture() {\r\n        return this._useTrueRenderingForDiffuseTexture;\r\n    }\r\n\r\n    public set useTrueRenderingForDiffuseTexture(use: boolean) {\r\n        if (this._useTrueRenderingForDiffuseTexture === use) {\r\n            return;\r\n        }\r\n\r\n        this._useTrueRenderingForDiffuseTexture = use;\r\n\r\n        if (use) {\r\n            this._particleSystem.blendMode = this._blendMode;\r\n            this._particleSystem.onBeforeDrawParticlesObservable.remove(\r\n                this._onBeforeDrawParticleObserver\r\n            );\r\n            this._onBeforeDrawParticleObserver = null;\r\n        } else {\r\n            this._particleSystem.blendMode = -1;\r\n            this._onBeforeDrawParticleObserver =\r\n                this._particleSystem.onBeforeDrawParticlesObservable.add(() => {\r\n                    this._engine.setAlphaMode(BABYLON.Constants.ALPHA_COMBINE);\r\n                });\r\n        }\r\n    }\r\n\r\n    constructor(scene: BABYLON.Scene, ps: BABYLON.ParticleSystem) {\r\n        super(\r\n            scene,\r\n            ps.vertexBuffers as { [key: string]: BABYLON.VertexBuffer },\r\n            ps.indexBuffer\r\n        );\r\n\r\n        this._particleSystem = ps;\r\n\r\n        this._renderCallback = ps.render.bind(ps);\r\n        this._blendMode = ps.blendMode;\r\n        this._onBeforeDrawParticleObserver = null;\r\n\r\n        ps.render = () => 0;\r\n\r\n        this.particleSize = (ps.minSize + ps.maxSize) / 2;\r\n\r\n        this.useTrueRenderingForDiffuseTexture = false;\r\n    }\r\n\r\n    public isReady(): boolean {\r\n        return super.isReady() && this._particleSystem.isReady();\r\n    }\r\n\r\n    public numParticles(): number {\r\n        return this._particleSystem.getActiveCount();\r\n    }\r\n\r\n    public renderDiffuseTexture(): void {\r\n        this._renderCallback();\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n\r\n        this._particleSystem.onBeforeDrawParticlesObservable.remove(\r\n            this._onBeforeDrawParticleObserver\r\n        );\r\n        this._onBeforeDrawParticleObserver = null;\r\n        this._particleSystem.render = this._renderCallback;\r\n        this._particleSystem.blendMode = this._blendMode;\r\n    }\r\n}\r\n","import * as BABYLON from \"@babylonjs/core\";\r\n\r\nimport { FluidRenderingObject } from \"./fluidRenderingObject\";\r\n\r\nexport class FluidRenderingObjectVertexBuffer extends FluidRenderingObject {\r\n    private _numParticles: number;\r\n    private _disposeVBOffset: boolean;\r\n    private _diffuseEffectWrapper: BABYLON.Nullable<BABYLON.EffectWrapper>;\r\n\r\n    public getClassName(): string {\r\n        return \"FluidRenderingObjectVertexBuffer\";\r\n    }\r\n\r\n    constructor(\r\n        scene: BABYLON.Scene,\r\n        vertexBuffers: { [key: string]: BABYLON.VertexBuffer },\r\n        numParticles: number\r\n    ) {\r\n        super(scene, vertexBuffers, null);\r\n\r\n        this._numParticles = numParticles;\r\n        this._disposeVBOffset = false;\r\n        this._diffuseEffectWrapper = null;\r\n\r\n        if (!vertexBuffers[\"offset\"]) {\r\n            vertexBuffers[\"offset\"] = new BABYLON.VertexBuffer(\r\n                this._engine,\r\n                [0, 0, 1, 0, 0, 1, 1, 1],\r\n                \"offset\",\r\n                false,\r\n                false,\r\n                2\r\n            );\r\n            this._disposeVBOffset = true;\r\n        }\r\n    }\r\n\r\n    protected _createEffects(): void {\r\n        super._createEffects();\r\n\r\n        const uniformNames = [\"view\", \"projection\", \"size\"];\r\n        const attributeNames = [\"position\", \"offset\", \"color\"];\r\n\r\n        this._diffuseEffectWrapper = new BABYLON.EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"fluidParticleDiffuse\",\r\n            fragmentShader: \"fluidParticleDiffuse\",\r\n            attributeNames,\r\n            uniformNames,\r\n            samplerNames: [],\r\n        });\r\n    }\r\n\r\n    public isReady(): boolean {\r\n        return (\r\n            super.isReady() &&\r\n            (this._diffuseEffectWrapper?.effect!.isReady() ?? false)\r\n        );\r\n    }\r\n\r\n    public numParticles(): number {\r\n        return this._numParticles;\r\n    }\r\n\r\n    public setNumParticles(num: number) {\r\n        this._numParticles = num;\r\n    }\r\n\r\n    public renderDiffuseTexture(): void {\r\n        const numParticles = this.numParticles();\r\n\r\n        if (!this._diffuseEffectWrapper || numParticles === 0) {\r\n            return;\r\n        }\r\n\r\n        const diffuseDrawWrapper = this._diffuseEffectWrapper._drawWrapper;\r\n        const diffuseEffect = diffuseDrawWrapper.effect!;\r\n\r\n        this._engine.enableEffect(diffuseDrawWrapper);\r\n        this._engine.bindBuffers(\r\n            this.vertexBuffers,\r\n            this.indexBuffer,\r\n            diffuseEffect\r\n        );\r\n\r\n        diffuseEffect.setMatrix(\"view\", this._scene.getViewMatrix());\r\n        diffuseEffect.setMatrix(\r\n            \"projection\",\r\n            this._scene.getProjectionMatrix()\r\n        );\r\n        if (this._particleSize !== null) {\r\n            diffuseEffect.setFloat2(\r\n                \"size\",\r\n                this._particleSize,\r\n                this._particleSize\r\n            );\r\n        }\r\n\r\n        if (this.useInstancing) {\r\n            this._engine.drawArraysType(\r\n                BABYLON.Constants.MATERIAL_TriangleStripDrawMode,\r\n                0,\r\n                4,\r\n                numParticles\r\n            );\r\n        } else {\r\n            this._engine.drawElementsType(\r\n                BABYLON.Constants.MATERIAL_TriangleFillMode,\r\n                0,\r\n                numParticles\r\n            );\r\n        }\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._diffuseEffectWrapper?.dispose();\r\n\r\n        if (this._disposeVBOffset) {\r\n            this.vertexBuffers[\"offset\"].dispose();\r\n        }\r\n    }\r\n}\r\n","import * as BABYLON from \"@babylonjs/core\";\r\n\r\nexport class CopyDepthTexture {\r\n    private _engine: BABYLON.Engine;\r\n    private _width: number;\r\n    private _height: number;\r\n    private _indexBuffer: BABYLON.Nullable<BABYLON.DataBuffer>;\r\n    private _vertexBuffers: {\r\n        [key: string]: BABYLON.Nullable<BABYLON.VertexBuffer>;\r\n    } = {};\r\n    private _depthRTWrapper: BABYLON.RenderTargetWrapper;\r\n    private _copyEffectWrapper: BABYLON.EffectWrapper;\r\n\r\n    public get depthRTWrapper() {\r\n        return this._depthRTWrapper;\r\n    }\r\n\r\n    constructor(engine: BABYLON.Engine, width: number, height: number) {\r\n        this._engine = engine;\r\n        this._width = width;\r\n        this._height = height;\r\n\r\n        this._depthRTWrapper = this._engine.createRenderTargetTexture(\r\n            { width, height },\r\n            {\r\n                generateMipMaps: false,\r\n                type: BABYLON.Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n                format: BABYLON.Constants.TEXTUREFORMAT_R,\r\n                samplingMode: BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: true,\r\n                generateStencilBuffer: false,\r\n                samples: 1,\r\n                noColorTarget: true,\r\n            }\r\n        );\r\n        this._depthRTWrapper.createDepthStencilTexture(0, false, false, 1);\r\n\r\n        this._copyEffectWrapper = new BABYLON.EffectWrapper({\r\n            engine: this._engine,\r\n            useShaderStore: true,\r\n            vertexShader: \"passDepth\",\r\n            fragmentShader: \"passDepth\",\r\n            attributeNames: [\"position\"],\r\n            uniformNames: [],\r\n            samplerNames: [\"textureDepth\"],\r\n            shaderLanguage: engine.isWebGPU\r\n                ? BABYLON.ShaderLanguage.WGSL\r\n                : BABYLON.ShaderLanguage.GLSL,\r\n        });\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] =\r\n            new BABYLON.VertexBuffer(\r\n                this._engine,\r\n                vertices,\r\n                BABYLON.VertexBuffer.PositionKind,\r\n                false,\r\n                false,\r\n                2\r\n            );\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    public copy(source: BABYLON.InternalTexture): boolean {\r\n        const effect = this._copyEffectWrapper.effect;\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._engine.bindFramebuffer(this._depthRTWrapper!);\r\n\r\n        this._engine.enableEffect(this._copyEffectWrapper._drawWrapper);\r\n\r\n        const engineDepthFunc = this._engine.getDepthFunction();\r\n\r\n        this._engine.setState(false);\r\n        this._engine.setDepthBuffer(true);\r\n        this._engine.setDepthWrite(true);\r\n        this._engine.setDepthFunction(BABYLON.Constants.ALWAYS);\r\n        this._engine.setColorWrite(false);\r\n\r\n        this._engine.bindBuffers(\r\n            this._vertexBuffers,\r\n            this._indexBuffer,\r\n            effect\r\n        );\r\n\r\n        effect._bindTexture(\"textureDepth\", source);\r\n\r\n        this._engine.drawElementsType(\r\n            BABYLON.Constants.MATERIAL_TriangleFillMode,\r\n            0,\r\n            6\r\n        );\r\n\r\n        this._engine.setDepthFunction(engineDepthFunc!);\r\n        this._engine.setColorWrite(true);\r\n\r\n        this._engine.unBindFramebuffer(this._depthRTWrapper!);\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose() {\r\n        this._depthRTWrapper.dispose();\r\n\r\n        this._vertexBuffers[BABYLON.VertexBuffer.PositionKind]?.dispose();\r\n        this._vertexBuffers = {};\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n    }\r\n}\r\n"],"names":["Object","defineProperty","get","this","_renderAsFluid","set","value","_scene","fluidRenderer","collectParticleSystems","enumerable","configurable","FluidRenderer","constructor","scene","_engine","getEngine","_onEngineResizeObserver","_renderObjects","_targetRenderers","_cameras","Map","_SceneComponentInitialization","onResizeObservable","add","_initialize","renderObjects","targetRenderers","recreate","_sortRenderingObjects","getRenderObjectFromParticleSystem","ps","index","_getParticleSystemIndex","getRenderObjectFromVertexBuffer","vb","_getVertexBufferIndex","addParticleSystem","generateDiffuseTexture","targetRenderer","camera","object","FluidRenderingObjectParticleSystem","onParticleSizeChanged","_setParticleSizeForRenderTargets","bind","FluidRenderingTargetRenderer","push","onUseVelocityChanged","hasObservers","_setUseVelocityForRenderObject","undefined","renderObject","addVertexBuffer","vertexBuffers","numParticles","FluidRenderingObjectVertexBuffer","removeRenderObject","removeUnusedTargetRenderer","indexOf","dispose","splice","_removeUnusedTargetRenderers","sort","a","b","priority","i","particleSystems","length","renderAsFluid","getClassName","indexes","removed","newList","static","obj","particleSystem","_IsParticleSystemObject","_IsVertexBufferObject","cameras","initialize","renderPostProcess","list","attachPostProcess","firstPostProcess","_getFirstPostProcess","copyDepthTextures","onSizeChangedObservable","inputTexture","depthStencilTexture","createDepthStencilTexture","isStencilEnable","samples","thicknessRT","thicknessRenderTarget","renderTarget","thicknessTexture","texture","key","width","height","copyDepthTexture","CopyDepthTexture","depthRTWrapper","_shareDepth","list2","clear","particleSizes","renderingObject","curSize","Math","max","particleSize","depthRenderTarget","useVelocity","_prepareRendering","needInitialization","_render","forCamera","clearTargets","sourceCopyDepth","_bgDepthTexture","copy","render","remove","FluidRenderingObject","indexBuffer","_particleSize","particleThicknessAlpha","_useVelocity","_effectsAreDirty","_depthEffectWrapper","_thicknessEffectWrapper","size","notifyObservers","useInstancing","use","_hasVelocity","velocity","_createEffects","uniformNames","attributeNames","defines","engine","useShaderStore","vertexShader","fragmentShader","samplerNames","isReady","depthEffect","_drawWrapper","effect","thicknessEffect","renderDepthTexture","depthDrawWrapper","enableEffect","bindBuffers","setMatrix","getViewMatrix","getProjectionMatrix","setFloat2","setFloat","drawArraysType","drawElementsType","renderThicknessTexture","thicknessDrawWrapper","setAlphaMode","setDepthWrite","renderDiffuseTexture","super","_useTrueRenderingForDiffuseTexture","_particleSystem","_renderCallback","_blendMode","blendMode","_onBeforeDrawParticleObserver","minSize","maxSize","useTrueRenderingForDiffuseTexture","onBeforeDrawParticlesObservable","getActiveCount","_numParticles","_disposeVBOffset","_diffuseEffectWrapper","setNumParticles","num","diffuseDrawWrapper","diffuseEffect","_vertexBuffers","_width","_height","_depthRTWrapper","createRenderTargetTexture","generateMipMaps","type","format","samplingMode","generateDepthBuffer","generateStencilBuffer","noColorTarget","_copyEffectWrapper","shaderLanguage","isWebGPU","vertices","indices","_indexBuffer","createIndexBuffer","source","bindFramebuffer","engineDepthFunc","getDepthFunction","setState","setDepthBuffer","setDepthFunction","setColorWrite","_bindTexture","unBindFramebuffer","_releaseBuffer"],"sourceRoot":""}