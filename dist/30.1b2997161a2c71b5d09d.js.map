{"version":3,"file":"30.1b2997161a2c71b5d09d.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/scenes/fluidSimulationDemoBoxSphere.ts"],"sourcesContent":["import * as BABYLON from \"@babylonjs/core\";\r\n\r\nimport * as LiLGUI from \"lil-gui\";\r\n\r\nimport { FluidSimulationDemoBase } from \"./fluidSimulationDemoBase\";\r\nimport { ICollisionShape } from \"./Utils/sdfHelper\";\r\n\r\nexport class FluidSimulationDemoBoxSphere extends FluidSimulationDemoBase {\r\n    private _checkXZBounds: boolean;\r\n    private _sphereMesh: BABYLON.Nullable<BABYLON.Mesh>;\r\n    private _boxMin: BABYLON.Vector3;\r\n    private _boxMax: BABYLON.Vector3;\r\n    private _boxMesh: BABYLON.Nullable<BABYLON.Mesh>;\r\n    private _boxMaterial: BABYLON.Nullable<BABYLON.PBRMaterial>;\r\n    private _boxMeshFront: BABYLON.Nullable<BABYLON.Mesh>;\r\n    private _boxMaterialFront: BABYLON.Nullable<BABYLON.PBRMaterial>;\r\n    private _origCollisionPlanes: Array<BABYLON.Plane>;\r\n    private _collisionPlanes: Array<\r\n        [BABYLON.Nullable<BABYLON.Mesh>, ICollisionShape]\r\n    >;\r\n    private _angleX: number;\r\n    private _angleY: number;\r\n    private _prevTransfo: BABYLON.Matrix;\r\n    private _autoRotateBox: boolean;\r\n    private _wallMesh: BABYLON.Nullable<BABYLON.Mesh>;\r\n    private _passPP: BABYLON.PostProcess;\r\n    private _sceneRenderObserver: BABYLON.Nullable<\r\n        BABYLON.Observer<BABYLON.Scene>\r\n    >;\r\n    private _sceneAfterCameraRenderObserver: BABYLON.Nullable<\r\n        BABYLON.Observer<BABYLON.Camera>\r\n    >;\r\n    private _sceneKeyboardObserver: BABYLON.Nullable<\r\n        BABYLON.Observer<BABYLON.KeyboardInfo>\r\n    >;\r\n    private _onEngineResizeObserver: BABYLON.Nullable<\r\n        BABYLON.Observer<BABYLON.Engine>\r\n    >;\r\n\r\n    constructor(scene: BABYLON.Scene) {\r\n        super(scene);\r\n\r\n        this._boxMin = new BABYLON.Vector3(-0.3, -0.3, -0.7);\r\n        this._boxMax = new BABYLON.Vector3(0.3, 1.2, 0.7);\r\n        this._boxMesh = null;\r\n        this._boxMaterial = null;\r\n        this._boxMeshFront = null;\r\n        this._boxMaterialFront = null;\r\n\r\n        this._checkXZBounds = true;\r\n        this._origCollisionPlanes = [\r\n            new BABYLON.Plane(0, 0, -1, Math.abs(this._boxMax.z)),\r\n            new BABYLON.Plane(0, 0, 1, Math.abs(this._boxMin.z)),\r\n            new BABYLON.Plane(1, 0, 0, Math.abs(this._boxMin.x)),\r\n            new BABYLON.Plane(-1, 0, 0, Math.abs(this._boxMax.x)),\r\n            new BABYLON.Plane(0, -1, 0, Math.abs(this._boxMax.y)),\r\n            new BABYLON.Plane(0, 1, 0, Math.abs(this._boxMin.y)),\r\n            new BABYLON.Plane(0, 1, 0, Math.abs(this._boxMin.y)),\r\n        ];\r\n        this._collisionPlanes = [];\r\n        for (let i = 0; i < this._origCollisionPlanes.length; ++i) {\r\n            const plane = this._origCollisionPlanes[i];\r\n            this.addCollisionPlane(\r\n                plane.normal,\r\n                plane.d,\r\n                i === this._origCollisionPlanes.length - 1 ? 0.98 : undefined\r\n            );\r\n        }\r\n\r\n        this._angleX = 0;\r\n        this._angleY = 0;\r\n        this._prevTransfo = BABYLON.Matrix.Identity();\r\n        this._autoRotateBox = false;\r\n\r\n        this._sceneRenderObserver = null;\r\n        this._sceneAfterCameraRenderObserver = null;\r\n        this._sceneKeyboardObserver = null;\r\n        this._onEngineResizeObserver = null;\r\n\r\n        this._passPP = new BABYLON.PassPostProcess(\r\n            \"pass\",\r\n            1,\r\n            null,\r\n            undefined,\r\n            this._engine\r\n        );\r\n        this._passPP.externalTextureSamplerBinding = true;\r\n\r\n        const sphereRadius = 0.16;\r\n\r\n        this._sphereMesh = null;\r\n        this.addCollisionSphere(\r\n            new BABYLON.Vector3(\r\n                (this._boxMin.x + this._boxMax.x) / 2,\r\n                this._boxMin.y + sphereRadius,\r\n                (this._boxMin.z + this._boxMax.z) / 2 - 0.1\r\n            ),\r\n            sphereRadius\r\n        );\r\n\r\n        this._wallMesh = null;\r\n        this.addCollisionBox(\r\n            new BABYLON.Vector3(0.0, 0.0, 0.3),\r\n            new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\r\n            new BABYLON.Vector3(0.32, 0.05, 0.3),\r\n            new BABYLON.Vector3(1, 0, 0)\r\n        );\r\n    }\r\n\r\n    protected async _run() {\r\n        // Get collision meshes\r\n        for (let i = 0; i < this._origCollisionPlanes.length; ++i) {\r\n            this._collisionPlanes.push(this._collisionObjects[i]);\r\n        }\r\n\r\n        this._collisionPlanes[this._collisionPlanes.length - 1][1].disabled =\r\n            true;\r\n\r\n        this._sphereMesh =\r\n            this._collisionObjects[this._origCollisionPlanes.length][0];\r\n        this._wallMesh =\r\n            this._collisionObjects[this._origCollisionPlanes.length + 1][0];\r\n\r\n        // Reset camera\r\n        const camera =\r\n            this._scene.activeCameras?.[0] ?? this._scene.activeCamera;\r\n\r\n        if (camera) {\r\n            (camera as BABYLON.ArcRotateCamera).alpha = 3.06;\r\n            (camera as BABYLON.ArcRotateCamera).beta = 1.14;\r\n            (camera as BABYLON.ArcRotateCamera).radius = 2.96;\r\n\r\n            camera.outputRenderTarget = new BABYLON.RenderTargetTexture(\r\n                \"rttFinal\",\r\n                {\r\n                    width: this._engine.getRenderWidth(),\r\n                    height: this._engine.getRenderHeight(),\r\n                },\r\n                this._scene\r\n            );\r\n        }\r\n\r\n        // Simulation parameters\r\n        this._fluidRenderObject.object.particleSize = 0.08;\r\n\r\n        this._fluidSim!.smoothingRadius = 0.04;\r\n        this._fluidSim!.densityReference = 20000;\r\n        this._fluidSim!.pressureConstant = 4;\r\n        this._fluidSim!.viscosity = 0.01;\r\n        this._fluidSim!.maxVelocity = 3;\r\n        this._fluidSim!.maxAcceleration = 2000;\r\n\r\n        // Create materials\r\n        this._boxMaterial = new BABYLON.PBRMaterial(\"BoxMeshMat\", this._scene);\r\n        this._boxMaterial.metallic = 0.3;\r\n        this._boxMaterial.roughness = 0;\r\n        this._boxMaterial.alpha = 0.2;\r\n        this._boxMaterial.backFaceCulling = true;\r\n        this._boxMaterial.cullBackFaces = false;\r\n\r\n        this._boxMaterialFront = this._boxMaterial.clone(\"BoxMeshFrontMat\");\r\n        this._boxMaterialFront.cullBackFaces = true;\r\n\r\n        // Create meshes\r\n        this._boxMesh = BABYLON.MeshBuilder.CreateBox(\r\n            \"boxMesh\",\r\n            {\r\n                width: this._boxMax.x - this._boxMin.x,\r\n                height: this._boxMax.y - this._boxMin.y,\r\n                depth: this._boxMax.z - this._boxMin.z,\r\n            },\r\n            this._scene\r\n        );\r\n        this._boxMesh.material = this._boxMaterial;\r\n        this._boxMesh.position.x = (this._boxMin.x + this._boxMax.x) / 2;\r\n        this._boxMesh.position.y = (this._boxMin.y + this._boxMax.y) / 2;\r\n        this._boxMesh.position.z = (this._boxMin.z + this._boxMax.z) / 2;\r\n        this._boxMesh.isPickable = false;\r\n\r\n        this._boxMeshFront = this._boxMesh.clone(\"boxMeshFront\");\r\n        this._boxMeshFront.material = this._boxMaterialFront;\r\n        this._boxMeshFront.layerMask = 0x10000000; // make sure the mesh is not displayed by the camera - we will display it ourselves by a direct call to render()\r\n\r\n        // Keyboard handling\r\n        let arrowLeftDown = false;\r\n        let arrowRightDown = false;\r\n        let arrowUpDown = false;\r\n        let arrowDownDown = false;\r\n\r\n        this._scene.onKeyboardObservable.add((kbInfo) => {\r\n            switch (kbInfo.type) {\r\n                case BABYLON.KeyboardEventTypes.KEYDOWN:\r\n                    if (kbInfo.event.code === \"ArrowLeft\") {\r\n                        arrowLeftDown = true;\r\n                    } else if (kbInfo.event.code === \"ArrowRight\") {\r\n                        arrowRightDown = true;\r\n                    } else if (kbInfo.event.code === \"ArrowUp\") {\r\n                        arrowUpDown = true;\r\n                    } else if (kbInfo.event.code === \"ArrowDown\") {\r\n                        arrowDownDown = true;\r\n                    }\r\n                    break;\r\n                case BABYLON.KeyboardEventTypes.KEYUP:\r\n                    if (kbInfo.event.code === \"ArrowLeft\") {\r\n                        arrowLeftDown = false;\r\n                    } else if (kbInfo.event.code === \"ArrowRight\") {\r\n                        arrowRightDown = false;\r\n                    } else if (kbInfo.event.code === \"ArrowUp\") {\r\n                        arrowUpDown = false;\r\n                    } else if (kbInfo.event.code === \"ArrowDown\") {\r\n                        arrowDownDown = false;\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n\r\n        // Render the front side of the box\r\n        this._passPP.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", camera!.outputRenderTarget);\r\n        });\r\n\r\n        let depthIsShared = false;\r\n        this._sceneAfterCameraRenderObserver =\r\n            this._scene.onAfterCameraRenderObservable.add(() => {\r\n                const firstPP = camera?._getFirstPostProcess();\r\n                if (\r\n                    firstPP &&\r\n                    firstPP.inputTexture.depthStencilTexture &&\r\n                    !depthIsShared\r\n                ) {\r\n                    firstPP.inputTexture._shareDepth(\r\n                        camera!.outputRenderTarget!.renderTarget!\r\n                    );\r\n                    depthIsShared = true;\r\n                }\r\n                if (depthIsShared) {\r\n                    this._boxMeshFront?.render(\r\n                        this._boxMeshFront.subMeshes[0],\r\n                        true\r\n                    );\r\n                    this._scene.postProcessManager.directRender(\r\n                        [this._passPP!],\r\n                        null\r\n                    );\r\n                }\r\n            });\r\n\r\n        this._onEngineResizeObserver = this._engine.onResizeObservable.add(\r\n            () => {\r\n                camera?.outputRenderTarget?.resize({\r\n                    width: this._engine.getRenderWidth(true),\r\n                    height: this._engine.getRenderHeight(true),\r\n                });\r\n                depthIsShared = false;\r\n            }\r\n        );\r\n\r\n        // Move meshes\r\n        this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(\r\n            () => {\r\n                if (arrowLeftDown) {\r\n                    this._angleX += (2 * 30) / 60;\r\n                    this._rotateMeshes(this._angleX, this._angleY);\r\n                }\r\n                if (arrowRightDown) {\r\n                    this._angleX -= (2 * 30) / 60;\r\n                    this._rotateMeshes(this._angleX, this._angleY);\r\n                }\r\n                if (arrowUpDown) {\r\n                    this._angleY -= (2 * 30) / 60;\r\n                    this._rotateMeshes(this._angleX, this._angleY);\r\n                }\r\n                if (arrowDownDown) {\r\n                    this._angleY += (2 * 30) / 60;\r\n                    this._rotateMeshes(this._angleX, this._angleY);\r\n                }\r\n\r\n                if (this._autoRotateBox) {\r\n                    const fps = this._engine.getFps();\r\n                    this._angleX += 20 / fps;\r\n                    this._angleY += 30 / fps;\r\n                    this._rotateMeshes(this._angleX, this._angleY);\r\n                }\r\n            }\r\n        );\r\n\r\n        super._run();\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        const camera =\r\n            this._scene.activeCameras?.[0] ?? this._scene.activeCamera;\r\n\r\n        if (camera) {\r\n            camera.outputRenderTarget?.dispose();\r\n            camera.outputRenderTarget = null;\r\n        }\r\n\r\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        this._scene.onAfterCameraRenderObservable.remove(\r\n            this._sceneAfterCameraRenderObserver\r\n        );\r\n        this._scene.onKeyboardObservable.remove(this._sceneKeyboardObserver);\r\n\r\n        this._passPP.dispose();\r\n        this._boxMesh?.dispose();\r\n        this._boxMeshFront?.dispose();\r\n        this._boxMaterial?.dispose();\r\n        this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\r\n    }\r\n\r\n    protected _makeGUIMainMenu(): void {\r\n        const params = {\r\n            checkXZBounds: true,\r\n            autoRotateBox: false,\r\n            restart: () => {\r\n                this._angleX = this._angleY = 0;\r\n                this._autoRotateBox = false;\r\n                autoRotateBoxCtrl?.setValue(false);\r\n                this._rotateMeshes(0, 0);\r\n                this._generateParticles();\r\n            },\r\n            boxOpacity: this._boxMaterial!.alpha,\r\n        };\r\n\r\n        const mainMenu = this._gui!;\r\n\r\n        let autoRotateBoxCtrl: BABYLON.Nullable<LiLGUI.Controller> = null;\r\n\r\n        mainMenu.add(params, \"restart\").name(\"Restart\");\r\n\r\n        mainMenu\r\n            .add(params, \"checkXZBounds\")\r\n            .name(\"Check box bounds\")\r\n            .onChange((value: boolean) => {\r\n                this._checkXZBounds = value;\r\n                this._boxMesh?.setEnabled(value);\r\n                this._boxMeshFront?.setEnabled(value);\r\n                for (let i = 0; i < this._collisionPlanes.length; ++i) {\r\n                    this._collisionPlanes[i][1].disabled =\r\n                        (!value && i < this._collisionPlanes.length - 1) ||\r\n                        (value && i === this._collisionPlanes.length - 1);\r\n                }\r\n                if (!value) {\r\n                    this._autoRotateBox = false;\r\n                    autoRotateBoxCtrl?.setValue(false);\r\n                }\r\n            });\r\n\r\n        autoRotateBoxCtrl = mainMenu\r\n            .add(params, \"autoRotateBox\")\r\n            .name(\"Auto rotate box\")\r\n            .onChange((value: boolean) => {\r\n                this._autoRotateBox = value;\r\n            });\r\n\r\n        mainMenu\r\n            .add(params, \"boxOpacity\", 0, 1, 0.01)\r\n            .name(\"Box opacity\")\r\n            .onChange((value: any) => {\r\n                this._boxMaterial!.alpha = value;\r\n                this._boxMaterialFront!.alpha = value;\r\n            });\r\n    }\r\n\r\n    protected _onPaused(value: boolean) {\r\n        super._onPaused(value);\r\n\r\n        if (value) {\r\n            this._autoRotateBox = false;\r\n        }\r\n    }\r\n\r\n    protected _rotateMeshes(angleX: number, angleY: number): void {\r\n        const transfo = BABYLON.Matrix.RotationYawPitchRoll(\r\n            0,\r\n            (angleX * Math.PI) / 180,\r\n            (angleY * Math.PI) / 180\r\n        );\r\n\r\n        const boxVertices = [\r\n            new BABYLON.Vector3(this._boxMin.x, this._boxMin.y, this._boxMin.z),\r\n            new BABYLON.Vector3(this._boxMin.x, this._boxMax.y, this._boxMin.z),\r\n            new BABYLON.Vector3(this._boxMin.x, this._boxMax.y, this._boxMax.z),\r\n            new BABYLON.Vector3(this._boxMin.x, this._boxMin.y, this._boxMax.z),\r\n            new BABYLON.Vector3(this._boxMax.x, this._boxMin.y, this._boxMin.z),\r\n            new BABYLON.Vector3(this._boxMax.x, this._boxMax.y, this._boxMin.z),\r\n            new BABYLON.Vector3(this._boxMax.x, this._boxMax.y, this._boxMax.z),\r\n            new BABYLON.Vector3(this._boxMax.x, this._boxMin.y, this._boxMax.z),\r\n        ];\r\n\r\n        let ymin = 1e10;\r\n        for (let i = 0; i < boxVertices.length; ++i) {\r\n            const v = BABYLON.Vector3.TransformCoordinates(\r\n                boxVertices[i],\r\n                transfo\r\n            );\r\n            ymin = Math.min(ymin, v.y);\r\n        }\r\n\r\n        this._collisionPlanes[\r\n            this._origCollisionPlanes.length - 1\r\n        ][1].params[1] = Math.abs(ymin) + 0.02;\r\n\r\n        for (let i = 0; i < this._origCollisionPlanes.length - 1; ++i) {\r\n            const plane = this._origCollisionPlanes[i].transform(transfo);\r\n            this._collisionPlanes[i][1].params = [plane.normal, plane.d];\r\n        }\r\n\r\n        const quat = BABYLON.Quaternion.FromRotationMatrix(transfo);\r\n\r\n        this._prevTransfo.invert();\r\n\r\n        if (this._sphereMesh) {\r\n            const tmp = BABYLON.Vector3.TransformCoordinates(\r\n                this._sphereMesh.position,\r\n                this._prevTransfo\r\n            );\r\n\r\n            this._sphereMesh.rotationQuaternion = quat;\r\n            this._sphereMesh.position = BABYLON.Vector3.TransformCoordinates(\r\n                tmp,\r\n                transfo\r\n            );\r\n        }\r\n\r\n        if (this._wallMesh) {\r\n            const tmp = BABYLON.Vector3.TransformCoordinates(\r\n                this._wallMesh.position,\r\n                this._prevTransfo\r\n            );\r\n\r\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\r\n                0,\r\n                (90 * Math.PI) / 180,\r\n                0\r\n            );\r\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\r\n\r\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\r\n            const qf =\r\n                this._wallMesh.rotationQuaternion ?? new BABYLON.Quaternion();\r\n\r\n            m.decompose(undefined, qf, this._wallMesh.position);\r\n\r\n            this._wallMesh.rotationQuaternion = qf;\r\n        }\r\n\r\n        if (this._boxMesh && this._boxMeshFront) {\r\n            this._boxMesh.rotationQuaternion =\r\n                this._boxMeshFront.rotationQuaternion = quat;\r\n            this._boxMesh.position.x = (this._boxMin.x + this._boxMax.x) / 2;\r\n            this._boxMesh.position.y = (this._boxMin.y + this._boxMax.y) / 2;\r\n            this._boxMesh.position.z = (this._boxMin.z + this._boxMax.z) / 2;\r\n            this._boxMesh.position = BABYLON.Vector3.TransformCoordinates(\r\n                this._boxMesh.position,\r\n                transfo\r\n            );\r\n            this._boxMeshFront.position = this._boxMesh.position;\r\n        }\r\n\r\n        this._prevTransfo.copyFrom(transfo);\r\n    }\r\n}\r\n"],"names":["FluidSimulationDemoBoxSphere","FluidSimulationDemoBase","constructor","scene","super","this","_boxMin","_boxMax","_boxMesh","_boxMaterial","_boxMeshFront","_boxMaterialFront","_checkXZBounds","_origCollisionPlanes","Math","abs","z","x","y","_collisionPlanes","i","length","plane","addCollisionPlane","normal","d","undefined","_angleX","_angleY","_prevTransfo","_autoRotateBox","_sceneRenderObserver","_sceneAfterCameraRenderObserver","_sceneKeyboardObserver","_onEngineResizeObserver","_passPP","_engine","externalTextureSamplerBinding","_sphereMesh","addCollisionSphere","_wallMesh","addCollisionBox","PI","async","push","_collisionObjects","disabled","camera","_scene","activeCameras","activeCamera","alpha","beta","radius","outputRenderTarget","width","getRenderWidth","height","getRenderHeight","_fluidRenderObject","object","particleSize","_fluidSim","smoothingRadius","densityReference","pressureConstant","viscosity","maxVelocity","maxAcceleration","metallic","roughness","backFaceCulling","cullBackFaces","clone","depth","material","position","isPickable","layerMask","arrowLeftDown","arrowRightDown","arrowUpDown","arrowDownDown","onKeyboardObservable","add","kbInfo","type","event","code","onApplyObservable","effect","setTexture","depthIsShared","onAfterCameraRenderObservable","firstPP","_getFirstPostProcess","inputTexture","depthStencilTexture","_shareDepth","renderTarget","render","subMeshes","postProcessManager","directRender","onResizeObservable","resize","onBeforeRenderObservable","_rotateMeshes","fps","getFps","_run","dispose","remove","_makeGUIMainMenu","params","checkXZBounds","autoRotateBox","restart","autoRotateBoxCtrl","setValue","_generateParticles","boxOpacity","mainMenu","_gui","name","onChange","value","setEnabled","_onPaused","angleX","angleY","transfo","boxVertices","ymin","v","min","transform","quat","invert","tmp","rotationQuaternion","m","t","multiplyToRef","qf","decompose","copyFrom"],"sourceRoot":""}