{"version":3,"file":"731.ae9d720a96e07c6ac93d.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderingRenderTarget.ts"],"sourcesContent":["import * as BABYLON from \"@babylonjs/core\";\r\n\r\nexport class FluidRenderingRenderTarget {\r\n    protected _name: string;\r\n    protected _scene: BABYLON.Scene;\r\n    protected _camera: BABYLON.Nullable<BABYLON.Camera>;\r\n    protected _engine: BABYLON.Engine;\r\n    protected _width: number;\r\n    protected _height: number;\r\n    protected _blurTextureSizeX: number;\r\n    protected _blurTextureSizeY: number;\r\n    protected _textureType: number;\r\n    protected _textureFormat: number;\r\n    protected _blurTextureType: number;\r\n    protected _blurTextureFormat: number;\r\n    protected _useStandardBlur: boolean;\r\n    protected _generateDepthBuffer: boolean;\r\n    protected _samples: number;\r\n    protected _postProcessRunningIndex: number;\r\n\r\n    protected _rt: BABYLON.Nullable<BABYLON.RenderTargetWrapper>;\r\n    protected _texture: BABYLON.Nullable<BABYLON.Texture>;\r\n    protected _rtBlur: BABYLON.Nullable<BABYLON.RenderTargetWrapper>;\r\n    protected _textureBlurred: BABYLON.Nullable<BABYLON.Texture>;\r\n    protected _blurPostProcesses: BABYLON.Nullable<BABYLON.PostProcess[]>;\r\n\r\n    public enableBlur = true;\r\n\r\n    public blurSizeDivisor = 1;\r\n\r\n    public blurFilterSize = 7;\r\n\r\n    private _blurNumIterations = 3;\r\n\r\n    public get blurNumIterations() {\r\n        return this._blurNumIterations;\r\n    }\r\n\r\n    public set blurNumIterations(numIterations: number) {\r\n        if (this._blurNumIterations === numIterations) {\r\n            return;\r\n        }\r\n\r\n        this._blurNumIterations = numIterations;\r\n        if (this._blurPostProcesses !== null) {\r\n            const blurX = this._blurPostProcesses[0];\r\n            const blurY = this._blurPostProcesses[1];\r\n\r\n            this._blurPostProcesses = [\r\n                ...Array(this._blurNumIterations * 2).keys(),\r\n            ].map((elm) => (elm & 1 ? blurY : blurX));\r\n        }\r\n    }\r\n\r\n    public blurMaxFilterSize = 100;\r\n\r\n    public blurDepthScale = 10;\r\n\r\n    public particleSize = 0.02;\r\n\r\n    public onDisposeObservable: BABYLON.Observable<FluidRenderingRenderTarget> =\r\n        new BABYLON.Observable<FluidRenderingRenderTarget>();\r\n\r\n    public get renderTarget() {\r\n        return this._rt;\r\n    }\r\n\r\n    public get renderTargetBlur() {\r\n        return this._rtBlur;\r\n    }\r\n\r\n    public get texture() {\r\n        return this._texture;\r\n    }\r\n\r\n    public get textureBlur() {\r\n        return this._textureBlurred;\r\n    }\r\n\r\n    constructor(\r\n        name: string,\r\n        scene: BABYLON.Scene,\r\n        width: number,\r\n        height: number,\r\n        blurTextureSizeX: number,\r\n        blurTextureSizeY: number,\r\n        textureType: number = BABYLON.Constants.TEXTURETYPE_FLOAT,\r\n        textureFormat: number = BABYLON.Constants.TEXTUREFORMAT_R,\r\n        blurTextureType: number = BABYLON.Constants.TEXTURETYPE_FLOAT,\r\n        blurTextureFormat: number = BABYLON.Constants.TEXTUREFORMAT_R,\r\n        useStandardBlur = false,\r\n        camera: BABYLON.Nullable<BABYLON.Camera> = null,\r\n        generateDepthBuffer = true,\r\n        samples = 1\r\n    ) {\r\n        this._name = name;\r\n        this._scene = scene;\r\n        this._camera = camera;\r\n        this._engine = scene.getEngine();\r\n        this._width = width;\r\n        this._height = height;\r\n        this._blurTextureSizeX = blurTextureSizeX;\r\n        this._blurTextureSizeY = blurTextureSizeY;\r\n        this._textureType = textureType;\r\n        this._textureFormat = textureFormat;\r\n        this._blurTextureType = blurTextureType;\r\n        this._blurTextureFormat = blurTextureFormat;\r\n        this._useStandardBlur = useStandardBlur;\r\n        this._generateDepthBuffer = generateDepthBuffer;\r\n        this._samples = samples;\r\n        this._postProcessRunningIndex = 0;\r\n        this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\r\n\r\n        this._rt = null;\r\n        this._texture = null;\r\n        this._rtBlur = null;\r\n        this._textureBlurred = null;\r\n        this._blurPostProcesses = null;\r\n    }\r\n\r\n    public initialize(): void {\r\n        this.dispose();\r\n\r\n        this._createRenderTarget();\r\n\r\n        if (this.enableBlur && this._texture) {\r\n            const [rtBlur, textureBlurred, blurPostProcesses] =\r\n                this._createBlurPostProcesses(\r\n                    this._texture,\r\n                    this._blurTextureType,\r\n                    this._blurTextureFormat,\r\n                    this.blurSizeDivisor,\r\n                    this._name,\r\n                    this._useStandardBlur\r\n                );\r\n            this._rtBlur = rtBlur;\r\n            this._textureBlurred = textureBlurred;\r\n            this._blurPostProcesses = blurPostProcesses;\r\n        }\r\n    }\r\n\r\n    public applyBlurPostProcesses(): void {\r\n        if (this.enableBlur && this._blurPostProcesses) {\r\n            this._postProcessRunningIndex = 0;\r\n            this._scene.postProcessManager.directRender(\r\n                this._blurPostProcesses,\r\n                this._rtBlur,\r\n                true\r\n            );\r\n            this._engine.unBindFramebuffer(this._rtBlur!);\r\n        }\r\n    }\r\n\r\n    protected _createRenderTarget(): void {\r\n        this._rt = this._engine.createRenderTargetTexture(\r\n            { width: this._width, height: this._height },\r\n            {\r\n                generateMipMaps: false,\r\n                type: this._textureType,\r\n                format: this._textureFormat,\r\n                samplingMode: BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: this._generateDepthBuffer,\r\n                generateStencilBuffer: false,\r\n                samples: this._samples,\r\n            }\r\n        );\r\n\r\n        const renderTexture = this._rt.texture!;\r\n\r\n        this._texture = new BABYLON.Texture(null, this._scene);\r\n        this._texture.name = \"rtt\" + this._name;\r\n        this._texture._texture = renderTexture;\r\n        this._texture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n        this._texture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n        this._texture.anisotropicFilteringLevel = 1;\r\n    }\r\n\r\n    protected _createBlurPostProcesses(\r\n        textureBlurSource: BABYLON.ThinTexture,\r\n        textureType: number,\r\n        textureFormat: number,\r\n        blurSizeDivisor: number,\r\n        debugName: string,\r\n        useStandardBlur = false\r\n    ): [BABYLON.RenderTargetWrapper, BABYLON.Texture, BABYLON.PostProcess[]] {\r\n        const engine = this._scene.getEngine();\r\n        const targetSize = new BABYLON.Vector2(\r\n            Math.floor(this._blurTextureSizeX / blurSizeDivisor),\r\n            Math.floor(this._blurTextureSizeY / blurSizeDivisor)\r\n        );\r\n        const useBilinearFiltering =\r\n            (textureType === BABYLON.Constants.TEXTURETYPE_FLOAT &&\r\n                engine.getCaps().textureFloatLinearFiltering) ||\r\n            (textureType === BABYLON.Constants.TEXTURETYPE_HALF_FLOAT &&\r\n                engine.getCaps().textureHalfFloatLinearFiltering);\r\n\r\n        const rtBlur = this._engine.createRenderTargetTexture(\r\n            { width: targetSize.x, height: targetSize.y },\r\n            {\r\n                generateMipMaps: false,\r\n                type: textureType,\r\n                format: textureFormat,\r\n                samplingMode: useBilinearFiltering\r\n                    ? BABYLON.Constants.TEXTURE_BILINEAR_SAMPLINGMODE\r\n                    : BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                samples: this._samples,\r\n            }\r\n        );\r\n\r\n        const renderTexture = rtBlur.texture!;\r\n\r\n        const texture = new BABYLON.Texture(null, this._scene);\r\n        texture.name = \"rttBlurred\" + debugName;\r\n        texture._texture = renderTexture;\r\n        texture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n        texture.anisotropicFilteringLevel = 1;\r\n\r\n        if (useStandardBlur) {\r\n            const kernelBlurXPostprocess = new BABYLON.PostProcess(\r\n                \"BilateralBlurX\",\r\n                \"standardBlur\",\r\n                [\"filterSize\", \"blurDir\"],\r\n                null,\r\n                1,\r\n                null,\r\n                BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurXPostprocess.samples = this._samples;\r\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                if (this._postProcessRunningIndex === 0) {\r\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\r\n                } else {\r\n                    effect._bindTexture(\r\n                        \"textureSampler\",\r\n                        kernelBlurXPostprocess.inputTexture.texture\r\n                    );\r\n                }\r\n                effect.setInt(\"filterSize\", this.blurFilterSize);\r\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurXPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\r\n\r\n            const kernelBlurYPostprocess = new BABYLON.PostProcess(\r\n                \"BilateralBlurY\",\r\n                \"standardBlur\",\r\n                [\"filterSize\", \"blurDir\"],\r\n                null,\r\n                1,\r\n                null,\r\n                BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurYPostprocess.samples = this._samples;\r\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setInt(\"filterSize\", this.blurFilterSize);\r\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurYPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\r\n\r\n            kernelBlurXPostprocess.autoClear = false;\r\n            kernelBlurYPostprocess.autoClear = false;\r\n\r\n            return [\r\n                rtBlur,\r\n                texture,\r\n                [...Array(this._blurNumIterations * 2).keys()].map((elm) =>\r\n                    elm & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess\r\n                ),\r\n            ];\r\n        } else {\r\n            const uniforms: string[] = [\r\n                \"maxFilterSize\",\r\n                \"blurDir\",\r\n                \"projectedParticleConstant\",\r\n                \"depthThreshold\",\r\n            ];\r\n\r\n            const kernelBlurXPostprocess = new BABYLON.PostProcess(\r\n                \"BilateralBlurX\",\r\n                \"bilateralBlur\",\r\n                uniforms,\r\n                null,\r\n                1,\r\n                null,\r\n                BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurXPostprocess.samples = this._samples;\r\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                if (this._postProcessRunningIndex === 0) {\r\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\r\n                } else {\r\n                    effect._bindTexture(\r\n                        \"textureSampler\",\r\n                        kernelBlurXPostprocess.inputTexture.texture\r\n                    );\r\n                }\r\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\r\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\r\n                effect.setFloat(\r\n                    \"projectedParticleConstant\",\r\n                    this._getProjectedParticleConstant()\r\n                );\r\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurXPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\r\n\r\n            const kernelBlurYPostprocess = new BABYLON.PostProcess(\r\n                \"BilateralBlurY\",\r\n                \"bilateralBlur\",\r\n                uniforms,\r\n                null,\r\n                1,\r\n                null,\r\n                BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurYPostprocess.samples = this._samples;\r\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\r\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\r\n                effect.setFloat(\r\n                    \"projectedParticleConstant\",\r\n                    this._getProjectedParticleConstant()\r\n                );\r\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurYPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\r\n\r\n            kernelBlurXPostprocess.autoClear = false;\r\n            kernelBlurYPostprocess.autoClear = false;\r\n\r\n            return [\r\n                rtBlur,\r\n                texture,\r\n                [...Array(this._blurNumIterations * 2).keys()].map((elm) =>\r\n                    elm & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess\r\n                ),\r\n            ];\r\n        }\r\n    }\r\n\r\n    private _fixReusablePostProcess(pp: BABYLON.PostProcess) {\r\n        if (!pp.isReusable()) {\r\n            return;\r\n        }\r\n\r\n        pp.onActivateObservable.add(() => {\r\n            // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\r\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\r\n        });\r\n        pp.onApplyObservable.add(() => {\r\n            // now we can advance to the next texture\r\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\r\n        });\r\n    }\r\n\r\n    private _getProjectedParticleConstant() {\r\n        return (\r\n            (this.blurFilterSize *\r\n                this.particleSize *\r\n                0.05 *\r\n                (this._height / 2)) /\r\n            Math.tan((this._camera?.fov ?? (45 * Math.PI) / 180) / 2)\r\n        );\r\n    }\r\n\r\n    private _getDepthThreshold() {\r\n        return (this.particleSize / 2) * this.blurDepthScale;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.onDisposeObservable.hasObservers()) {\r\n            this.onDisposeObservable.notifyObservers(this);\r\n        }\r\n\r\n        this._rt?.dispose();\r\n        this._rt = null;\r\n        this._rtBlur?.dispose();\r\n        this._rtBlur = null;\r\n        if (this._blurPostProcesses) {\r\n            this._blurPostProcesses[0].dispose();\r\n            this._blurPostProcesses[1].dispose();\r\n        }\r\n        this._blurPostProcesses = null;\r\n    }\r\n}\r\n"],"names":["FluidRenderingRenderTarget","constructor","name","scene","width","height","blurTextureSizeX","blurTextureSizeY","textureType","textureFormat","blurTextureType","blurTextureFormat","useStandardBlur","camera","generateDepthBuffer","samples","enableBlur","blurSizeDivisor","blurFilterSize","_blurNumIterations","blurMaxFilterSize","blurDepthScale","particleSize","onDisposeObservable","this","_name","_scene","_camera","_engine","getEngine","_width","_height","_blurTextureSizeX","_blurTextureSizeY","_textureType","_textureFormat","_blurTextureType","_blurTextureFormat","_useStandardBlur","_generateDepthBuffer","_samples","_postProcessRunningIndex","_rt","_texture","_rtBlur","_textureBlurred","_blurPostProcesses","blurNumIterations","numIterations","blurX","blurY","Array","keys","map","elm","renderTarget","renderTargetBlur","texture","textureBlur","initialize","dispose","_createRenderTarget","rtBlur","textureBlurred","blurPostProcesses","_createBlurPostProcesses","applyBlurPostProcesses","postProcessManager","directRender","unBindFramebuffer","createRenderTargetTexture","generateMipMaps","type","format","samplingMode","generateStencilBuffer","renderTexture","wrapU","wrapV","anisotropicFilteringLevel","textureBlurSource","debugName","engine","targetSize","Math","floor","useBilinearFiltering","getCaps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","x","y","kernelBlurXPostprocess","undefined","externalTextureSamplerBinding","onApplyObservable","add","effect","setTexture","_bindTexture","inputTexture","setInt","setFloat2","onSizeChangedObservable","_textures","forEach","rt","_fixReusablePostProcess","kernelBlurYPostprocess","autoClear","uniforms","setFloat","_getProjectedParticleConstant","_getDepthThreshold","pp","isReusable","onActivateObservable","_currentRenderTextureInd","tan","fov","PI","hasObservers","notifyObservers"],"sourceRoot":""}